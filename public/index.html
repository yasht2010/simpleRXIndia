<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clinova Rx</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        @media print {
            * {
                background: transparent !important;
                box-shadow: none !important;
                color: black !important;
            }

            .no-print {
                display: none !important;
            }

            body {
                background: white !important;
                font-size: 12pt;
                margin: 0;
            }

            .print-area {
                border: none !important;
                box-shadow: none !important;
                padding: 0 !important;
            }

            .rx-medicine {
                text-decoration: none !important;
                border: none !important;
            }
        }

        #content table {
            width: 100%;
            max-width: 100%;
            table-layout: fixed;
        }

        #content th,
        #content td {
            word-break: break-word;
        }

        .rx-medicine {
            cursor: pointer;
            position: relative;
        }

        .rx-popover {
            position: absolute;
            background: white;
            border: 1px solid #e2e8f0;
            box-shadow: 0 12px 30px rgba(15, 23, 42, 0.12);
            border-radius: 12px;
            padding: 12px;
            width: min(360px, 90vw);
            z-index: 50;
        }

        .rx-popover input {
            width: 100%;
            border: 1px solid #cbd5e1;
            border-radius: 10px;
            padding: 10px 12px;
            font-size: 14px;
            outline: none;
        }

        .rx-suggestions {
            margin-top: 8px;
            max-height: 240px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
        }

        .rx-suggestion {
            padding: 10px;
            border-bottom: 1px solid #f1f5f9;
            cursor: pointer;
        }

        .rx-suggestion:last-child {
            border-bottom: none;
        }

        .rx-suggestion:hover,
        .rx-suggestion.active {
            background: #eef2ff;
        }

        .rx-suggestion .name {
            font-weight: 700;
            color: #0f172a;
        }

        .rx-suggestion .molecules {
            color: #475569;
            font-size: 13px;
            margin-top: 2px;
        }

        .rx-suggestion .meta {
            color: #6b7280;
            font-size: 12px;
        }

        .rx-empty {
            padding: 10px;
            color: #6b7280;
            text-align: center;
        }

        .rx-foot {
            margin-top: 6px;
            font-size: 12px;
            color: #94a3b8;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .rx-pill {
            padding: 4px 8px;
            background: #e0f2fe;
            color: #0369a1;
            border-radius: 999px;
            font-weight: 600;
            font-size: 12px;
        }
    </style>
</head>

<body class="bg-slate-50 min-h-screen p-4 sm:p-6 md:p-8 font-sans text-slate-800 text-base leading-relaxed">

    <!-- LOGIN UI -->
    <div id="loginScreen" class="min-h-screen flex items-center justify-center">
        <div class="w-full max-w-5xl grid md:grid-cols-2 gap-8 md:gap-10 items-center px-1">
            <div class="space-y-4">
                <p
                    class="inline-flex items-center gap-2 text-xs font-semibold text-blue-900 bg-blue-100 px-3 py-1 rounded-full w-fit tracking-tight">
                    Clinova Rx ¬∑ India</p>
                <h1 class="text-4xl md:text-5xl font-extrabold text-blue-900 leading-tight tracking-tight">Dictate
                    faster, prescribe smarter.</h1>
                <p class="text-lg text-slate-700">Voice-first scribing built for Indian doctors. Capture visits in
                    seconds, auto-format Rx, and print instantly.</p>
                <div class="grid grid-cols-2 gap-4 text-sm text-slate-700">
                    <div class="bg-white border border-slate-200 rounded-xl p-4 shadow-lg">
                        <div class="text-2xl font-bold text-blue-900">10x</div>
                        <div class="text-xs uppercase tracking-wide text-slate-500">Faster note taking</div>
                    </div>
                    <div class="bg-white border border-slate-200 rounded-xl p-4 shadow-lg">
                        <div class="text-2xl font-bold text-blue-900">Secure</div>
                        <div class="text-xs uppercase tracking-wide text-slate-500">On-device mic, secured APIs</div>
                    </div>
                </div>
                <ul class="space-y-2 text-sm text-slate-700">
                    <li class="flex items-start gap-2"><span class="mt-2 h-1.5 w-1.5 rounded-full bg-blue-700"></span>
                        Live transcription tuned for EN-IN medical dictation</li>
                    <li class="flex items-start gap-2"><span class="mt-2 h-1.5 w-1.5 rounded-full bg-blue-700"></span>
                        One-tap macros for common protocols and advice</li>
                    <li class="flex items-start gap-2"><span class="mt-2 h-1.5 w-1.5 rounded-full bg-blue-700"></span>
                        Print-ready HTML prescription with your header and NMC ID</li>
                </ul>
            </div>
            <div class="bg-white p-8 rounded-2xl shadow-2xl border border-slate-200">
                <h2 class="text-2xl font-bold text-blue-900 mb-2 tracking-tight">Login to continue</h2>
                <p class="text-sm text-slate-600 mb-4">Access your prescriptions, macros, and settings.</p>
                <input id="loginPhone" placeholder="Phone Number"
                    class="w-full bg-slate-50 border border-slate-300 p-3 rounded-md mb-3 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                <input id="loginPass" type="password" placeholder="Password"
                    class="w-full bg-slate-50 border border-slate-300 p-3 rounded-md mb-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                <p id="loginError" class="text-xs text-rose-600 h-4 mb-2"></p>
                <button id="loginButton" onclick="login()"
                    class="w-full bg-blue-800 hover:bg-blue-900 text-white py-3 rounded-lg font-semibold shadow transition-all">Login</button>
                <div class="text-center text-xs text-slate-500 mt-4">
                    New here? <a href="/register" class="text-blue-800 font-semibold hover:underline">Create an
                        account</a>
                </div>
            </div>
        </div>
    </div>

    <div id="loginLoading"
        class="hidden fixed inset-0 z-50 bg-white/90 backdrop-blur-sm flex items-center justify-center">
        <div class="bg-white border border-slate-200 shadow-2xl rounded-2xl px-6 py-5 flex items-center gap-4">
            <div class="w-10 h-10 rounded-full border-4 border-blue-200 border-t-blue-800 animate-spin"></div>
            <div>
                <div class="text-sm font-semibold text-blue-900">Signing you in‚Ä¶</div>
                <div class="text-xs text-slate-600">Please wait while we load your dashboard.</div>
            </div>
        </div>
    </div>

    <!-- MAIN APP -->
    <div id="appScreen" class="hidden min-h-screen flex flex-col items-center gap-4">
        <div class="w-full max-w-3xl no-print px-1 sm:px-0">
            <div class="text-blue-900 font-extrabold text-3xl tracking-tight">Clinova Rx</div>
        </div>
        <div class="w-full max-w-3xl no-print mb-4 px-1 sm:px-0">
            <div
                class="bg-white border border-slate-200 rounded-lg shadow px-4 py-3 text-sm font-semibold text-slate-800">
                <div class="sm:hidden space-y-2">
                    <div class="flex items-center justify-between gap-3">
                        <button onclick="openMacros()" class="text-slate-800 hover:text-blue-700">Voice Macros</button>
                        <div class="flex items-center gap-2">
                            <span class="px-3 py-1 rounded-full bg-slate-100 text-slate-800">Rx: <span
                                    id="creditDisplay">0</span></span>
                            <button onclick="logout()" class="text-slate-700 hover:text-blue-700">Logout</button>
                            <button onclick="openSettings()"
                                class="w-9 h-9 rounded-full bg-white border border-slate-200 shadow-sm hover:border-blue-300 flex items-center justify-center text-slate-700 hover:text-blue-800"
                                aria-label="Profile">
                                <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M12 12a5 5 0 1 0-5-5 5 5 0 0 0 5 5Z" />
                                    <path d="M4 21a8 8 0 0 1 16 0" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="flex justify-center">
                        <div id="aiReviewToggleMobile"
                            class="relative flex items-center gap-2 bg-white border border-slate-200 rounded-md px-3 py-2 cursor-pointer hover:shadow-md transition w-full justify-between"
                            onclick="handleAiToggleClick()">
                            <div class="flex flex-col leading-tight">
                                <div class="text-[10px] uppercase tracking-wide text-slate-500">AI Reviewer</div>
                                <div id="aiToggleLabelMobile" class="text-sm font-semibold text-blue-900">Enabled</div>
                            </div>
                            <div class="flex items-center gap-2">
                                <div class="relative group">
                                    <button type="button"
                                        class="inline-flex items-center justify-center w-6 h-6 rounded-full bg-blue-50 text-blue-600 text-xs font-bold focus:outline-none">
                                        i
                                    </button>
                                    <div
                                        class="absolute left-1/2 -translate-x-1/2 top-full mt-2 w-64 text-xs text-slate-700 bg-white border border-slate-200 rounded-lg shadow-xl px-3 py-2 opacity-0 group-hover:opacity-100 group-focus-within:opacity-100 transition z-40">
                                        Automatically reviews AI output for safety, catches hallucinations, and formats
                                        before printing.
                                    </div>
                                </div>
                                <div id="aiToggleTrackMobile"
                                    class="w-12 h-6 rounded-full bg-slate-200 transition relative overflow-hidden">
                                    <div id="aiToggleKnobMobile"
                                        class="absolute top-0.5 left-0.5 w-5 h-5 rounded-full bg-white shadow transition-transform duration-200">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="hidden sm:grid grid-cols-3 items-center gap-2">
                    <div class="flex items-center justify-start">
                        <button onclick="openMacros()" class="text-slate-800 hover:text-blue-700">Voice Macros</button>
                    </div>
                    <div class="flex justify-center">
                        <div id="aiReviewToggle"
                            class="relative flex items-center gap-2 bg-white border border-slate-200 rounded-md px-3 py-2 cursor-pointer hover:shadow-md transition"
                            onclick="handleAiToggleClick()">
                            <div class="flex flex-col leading-tight">
                                <div class="text-[10px] uppercase tracking-wide text-slate-500">AI Reviewer</div>
                                <div id="aiToggleLabel" class="text-sm font-semibold text-blue-900">Enabled</div>
                            </div>
                            <div class="flex items-center gap-2">
                                <div class="relative group">
                                    <button type="button"
                                        class="inline-flex items-center justify-center w-6 h-6 rounded-full bg-blue-50 text-blue-600 text-xs font-bold focus:outline-none">
                                        i
                                    </button>
                                    <div
                                        class="absolute left-1/2 -translate-x-1/2 top-full mt-2 w-64 text-xs text-slate-700 bg-white border border-slate-200 rounded-lg shadow-xl px-3 py-2 opacity-0 group-hover:opacity-100 group-focus-within:opacity-100 transition z-40">
                                        Automatically reviews AI output for safety, catches hallucinations, and formats
                                        before printing.
                                    </div>
                                </div>
                                <div id="aiToggleTrack"
                                    class="w-12 h-6 rounded-full bg-slate-200 transition relative overflow-hidden">
                                    <div id="aiToggleKnob"
                                        class="absolute top-0.5 left-0.5 w-5 h-5 rounded-full bg-white shadow transition-transform duration-200">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="flex items-center justify-end gap-3">
                        <span class="px-3 py-1 rounded-full bg-slate-100 text-slate-800">Rx: <span
                                id="creditDisplayDesktop">0</span></span>
                        <button onclick="logout()" class="text-slate-700 hover:text-blue-700">Logout</button>
                        <button onclick="openSettings()" title="Profile & Settings"
                            class="w-9 h-9 rounded-full bg-white border border-slate-200 shadow-sm hover:border-blue-300 flex items-center justify-center text-slate-700 hover:text-blue-800">
                            <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 12a5 5 0 1 0-5-5 5 5 0 0 0 5 5Z" />
                                <path d="M4 21a8 8 0 0 1 16 0" />
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div
            class="max-w-3xl w-full bg-white rounded-2xl shadow-2xl border border-slate-200 overflow-visible print-area min-h-[65vh] sm:min-h-[75vh] md:min-h-[80vh] flex flex-col relative">
            <div class="px-4 sm:px-6 py-3 sm:py-4 flex justify-end items-center border-b border-slate-100 no-print">
                <span id="headerStatus" class="text-xs text-emerald-600 h-4 font-semibold"></span>
            </div>
            <div class="relative">
                <div id="docHeader" contenteditable="true"
                    class="p-4 sm:p-6 md:p-8 cursor-text hover:bg-slate-50 transition font-sans text-slate-800"></div>
                <div id="headerActions"
                    class="hidden absolute top-3 right-3 sm:top-4 sm:right-6 flex items-center gap-2 bg-white/95 border border-slate-200 rounded-md shadow px-2 py-1 no-print">
                    <button onclick="saveHeader()"
                        class="w-8 h-8 flex items-center justify-center rounded-md bg-emerald-500 text-white hover:bg-emerald-600 transition"
                        aria-label="Save header">
                        <svg class="w-4 h-4" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2"
                            stroke-linecap="round" stroke-linejoin="round">
                            <path d="M4 10.5 8.5 15 16 6" />
                        </svg>
                    </button>
                    <button onclick="discardHeaderChanges()"
                        class="w-8 h-8 flex items-center justify-center rounded-md bg-rose-500 text-white hover:bg-rose-600 transition"
                        aria-label="Discard header changes">
                        <svg class="w-4 h-4" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2"
                            stroke-linecap="round" stroke-linejoin="round">
                            <path d="M5 5 15 15M15 5 5 15" />
                        </svg>
                    </button>
                </div>
            </div>
            <div id="livePreview" class="px-4 sm:px-8 pt-2 text-slate-400 text-sm italic h-6 overflow-hidden"></div>
            <div id="content" contenteditable="true"
                class="p-4 sm:p-6 md:p-8 flex-grow prose max-w-none focus:outline-none font-sans text-slate-800 overflow-x-auto">
                <p id="placeholder" class="text-slate-300 italic no-print">Tap to start prescription...</p>
            </div>
            <div class="bg-white px-4 sm:px-6 md:px-8 py-4 sm:py-5 border-t border-slate-100 no-print">
                <div class="w-full max-w-3xl mx-auto flex flex-col items-center gap-3">
                    <div id="countdownBadge"
                        class="hidden text-xs font-semibold text-amber-600 bg-amber-100 px-2 py-1 rounded-full text-center">
                    </div>
                    <div class="w-full">
                        <canvas id="waveform"
                            class="w-full h-10 rounded-full bg-slate-100 border border-slate-200 opacity-0 transition-opacity duration-500"></canvas>
                    </div>
                    <div class="relative flex flex-col items-center gap-1">
                        <div class="flex items-center gap-4">
                            <button id="recordFab" onclick="handleRecordAction()"
                                class="w-16 h-16 sm:w-20 sm:h-20 rounded-full bg-rose-600 text-white shadow-xl border-4 border-white flex items-center justify-center transition-all active:scale-95">
                                <svg id="recordIcon" class="w-7 h-7" fill="currentColor" viewBox="0 0 24 24">
                                    <path d="M12 14a3 3 0 0 0 3-3V7a3 3 0 1 0-6 0v4a3 3 0 0 0 3 3Z" />
                                    <path d="M7 11a5 5 0 0 0 10 0h-1.5a3.5 3.5 0 0 1-7 0H7Z" />
                                    <path d="M12 17v3m0 0h-3m3 0h3" stroke="currentColor" stroke-width="1.5"
                                        stroke-linecap="round" />
                                </svg>
                            </button>
                            <button id="stopButton" onclick="handleStopAction()"
                                class="hidden w-16 h-16 sm:w-20 sm:h-20 rounded-full bg-slate-800 text-white shadow-xl border-4 border-white flex items-center justify-center transition-all active:scale-95">
                                <svg id="stopIcon" class="w-6 h-6" viewBox="0 0 24 24" fill="currentColor">
                                    <rect x="6" y="6" width="12" height="12" rx="2" />
                                </svg>
                                <span class="sr-only">Stop</span>
                            </button>
                        </div>
                    </div>
                    <p id="recordLabel" class="text-sm font-semibold text-slate-700">Tap to start prescription</p>
                    <p id="status"
                        class="text-center text-xs text-slate-500 font-bold min-h-[1.5rem] whitespace-pre-line px-4">
                        READY</p>
                </div>
                <div class="w-full flex flex-col md:grid md:grid-cols-3 items-center mt-4 gap-3">
                    <div class="flex justify-center w-full order-1 md:order-2">
                        <div class="text-blue-900 font-mono text-lg tracking-wide" id="timerDisplay">00:00</div>
                    </div>
                    <div
                        class="flex justify-center md:justify-end items-center gap-3 w-full order-2 md:order-3 md:pr-2 lg:pr-4">
                        <button onclick="handleClear()"
                            class="px-4 py-2 text-slate-700 hover:bg-slate-100 rounded-lg text-xs font-semibold">Clear</button>
                        <button onclick="handleCopy()"
                            class="bg-white border border-slate-200 hover:border-blue-300 text-slate-800 px-4 py-2 rounded-lg text-sm font-semibold shadow-sm transition inline-flex items-center gap-2">
                            <svg class="w-4 h-4" viewBox="0 0 20 20" fill="none" stroke="currentColor"
                                stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                                <path
                                    d="M6 6.75A1.75 1.75 0 0 1 7.75 5h5.5A1.75 1.75 0 0 1 15 6.75v8.5A1.75 1.75 0 0 1 13.25 17h-5.5A1.75 1.75 0 0 1 6 15.25z" />
                                <path d="M12 3H6.75A1.75 1.75 0 0 0 5 4.75v9.5" />
                            </svg>
                            Copy
                        </button>
                        <button onclick="handlePrint()"
                            class="bg-blue-800 hover:bg-blue-900 text-white px-5 py-2 rounded-lg text-sm font-semibold shadow transition inline-flex items-center gap-2">
                            <svg class="w-4 h-4" viewBox="0 0 20 20" fill="none" stroke="currentColor"
                                stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M6 8V4.5A1.5 1.5 0 0 1 7.5 3h5A1.5 1.5 0 0 1 14 4.5V8" />
                                <rect x="5" y="9" width="10" height="6.5" rx="1" />
                                <path d="M7 13.5h6" />
                            </svg>
                            Print
                        </button>
                    </div>
                    <div
                        class="flex justify-center md:justify-start items-center gap-3 w-full order-3 md:order-1 md:pl-2 lg:pl-4">
                        <div class="relative">
                            <button id="fontButton" onclick="toggleFontMenu()"
                                class="bg-white border border-slate-200 rounded-md px-3 py-2 text-xs font-medium text-slate-700 shadow-sm flex items-center gap-1 focus:outline-none focus:ring-2 focus:ring-blue-500 hover:border-blue-300">
                                <svg class="w-4 h-4 text-slate-600" fill="none" stroke="currentColor"
                                    viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8"
                                        d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.89 3.31.877 2.42 2.42a1.724 1.724 0 001.065 2.572c1.757.426 1.757 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.89 1.543-.877 3.31-2.42 2.42a1.724 1.724 0 00-2.572 1.065c-.427 1.757-2.925 1.757-3.351 0a1.724 1.724 0 00-2.572-1.066c-1.543.89-3.31-.876-2.42-2.42a1.724 1.724 0 00-1.065-2.572c-1.757-.427-1.757-2.925 0-3.351a1.724 1.724 0 001.066-2.572c-.89-1.543.877-3.31 2.42-2.42.996.574 2.273.096 2.572-1.065z" />
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8"
                                        d="M12 15.75a3.75 3.75 0 100-7.5 3.75 3.75 0 000 7.5z" />
                                </svg>
                            </button>
                            <div id="fontMenu"
                                class="hidden absolute left-0 bottom-full mb-1 w-56 bg-white border border-slate-200 rounded-md shadow-lg text-xs font-medium text-slate-800 z-50 p-3 space-y-3">
                                <div>
                                    <label class="block text-[11px] text-slate-600 mb-1">Font family</label>
                                    <select id="fontFamilySelect"
                                        class="w-full bg-slate-50 border border-slate-200 rounded-md px-2 py-1 text-xs text-slate-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
                                        <option value="'Inter', sans-serif">Sans (Inter)</option>
                                        <option value="Georgia, serif">Serif (Georgia)</option>
                                        <option value="'Source Sans Pro', sans-serif">Sans (Source Sans)</option>
                                        <option value="'Roboto Mono', monospace">Mono (Roboto Mono)</option>
                                    </select>
                                </div>
                                <div>
                                    <label class="block text-[11px] text-slate-600 mb-1">Font size</label>
                                    <select id="fontSizeSelect"
                                        class="w-full bg-slate-50 border border-slate-200 rounded-md px-2 py-1 text-xs text-slate-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
                                        <option value="14px" selected>14 px</option>
                                        <option value="16px">16 px</option>
                                        <option value="18px">18 px</option>
                                        <option value="20px">20 px</option>
                                    </select>
                                </div>
                                <div class="flex justify-end">
                                    <button class="text-blue-800 text-xs font-semibold"
                                        onclick="applyFontSettings()">Apply</button>
                                </div>
                            </div>
                        </div>
                        <div class="relative">
                            <button id="modeButton" onclick="toggleModeMenu()"
                                class="bg-white border border-slate-200 rounded-md px-3 py-2 text-xs font-medium text-slate-700 shadow-sm flex items-center gap-2 focus:outline-none focus:ring-2 focus:ring-blue-500 hover:border-blue-300">
                                <span id="modeLabel" class="flex items-center gap-1 whitespace-nowrap">üîç Offline (High
                                    Accuracy)</span>
                                <span class="text-slate-500 text-xs">‚åÑ</span>
                            </button>
                            <div id="modeMenu"
                                class="hidden absolute right-0 bottom-full mb-1 w-56 bg-white border border-slate-200 rounded-md shadow-lg text-xs font-medium text-slate-800 z-50">
                                <div class="flex items-center justify-between px-3 py-2 cursor-pointer hover:bg-slate-50"
                                    onclick="selectMode('live')">
                                    <span class="flex items-center gap-2 whitespace-nowrap">‚ö° Live (Faster)</span>
                                    <span id="checkLive" class="text-blue-600 text-xs">‚úì</span>
                                </div>
                                <div class="border-t border-slate-200"></div>
                                <div class="flex items-center justify-between px-3 py-2 cursor-pointer hover:bg-slate-50"
                                    onclick="selectMode('offline')">
                                    <span class="flex items-center gap-2 whitespace-nowrap">üîç Offline (High
                                        Accuracy)</span>
                                    <span id="checkOffline" class="text-blue-600 text-xs hidden">‚úì</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- SETTINGS & MACRO MODALS (Standard) -->
    <div id="settingsModal" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-50 no-print">
        <div class="bg-white rounded-2xl p-6 w-full max-w-lg shadow-2xl border border-slate-200">
            <h2 class="font-bold text-blue-900 mb-4 tracking-tight">Settings</h2>
            <p class="text-xs text-slate-600 mb-3">Update your profile header and custom keywords (comma separated brand
                names for stronger ASR bias).</p>
            <input id="in_name" placeholder="Name"
                class="w-full bg-slate-50 border border-slate-300 p-3 mb-2 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            <input id="in_qual" placeholder="Qualifications"
                class="w-full bg-slate-50 border border-slate-300 p-3 mb-2 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            <input id="in_reg" placeholder="Reg No"
                class="w-full bg-slate-50 border border-slate-300 p-3 mb-2 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            <textarea id="in_clinic" placeholder="Clinic Address"
                class="w-full bg-slate-50 border border-slate-300 p-3 mb-2 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"></textarea>
            <input id="in_keywords" placeholder="Keywords (Brand names)"
                class="w-full bg-slate-50 border border-slate-300 p-3 mb-2 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            <div class="mt-4 border-t border-slate-200 pt-4 space-y-3">
                <div>
                    <div class="flex items-center justify-between gap-2">
                        <label class="text-sm font-semibold text-slate-800">Upload saved audio (quiet testing)</label>
                        <button id="testUploadButton" onclick="triggerTestUpload()"
                            class="text-xs text-blue-900 bg-blue-50 hover:bg-blue-100 border border-blue-200 px-3 py-2 rounded-md shadow-sm transition">
                            Choose file
                        </button>
                    </div>
                    <p class="text-[11px] text-slate-500 mt-1">Upload a saved audio or webm clip to process without
                        speaking.</p>
                    <input id="testAudioInput" type="file" accept="audio/*,video/webm" class="hidden"
                        onchange="handleTestFile(this.files?.[0])">
                </div>

            </div>
            <p id="settingsStatus" class="text-xs h-4 text-emerald-600 font-semibold"></p>
            <div class="flex justify-end gap-3 mt-4">
                <button onclick="document.getElementById('settingsModal').classList.add('hidden')"
                    class="px-4 py-2 text-slate-600 hover:bg-slate-100 rounded-lg">Cancel</button>
                <button onclick="saveSettings()"
                    class="bg-blue-800 hover:bg-blue-900 text-white px-5 py-2 rounded-lg font-semibold shadow transition">Save</button>
            </div>
        </div>
    </div>

    <div id="macroModal" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-50 no-print">
        <div class="bg-white rounded-2xl p-6 w-full max-w-2xl shadow-2xl border border-slate-200">
            <h2 class="font-bold text-blue-900 mb-1 tracking-tight">Macros</h2>
            <p class="text-xs text-slate-600 mb-3">Speak the trigger phrase during dictation to insert the macro (e.g.,
                ‚Äúapply fever protocol‚Äù).</p>
            <input id="macroTrigger" placeholder="Trigger"
                class="w-full bg-slate-50 border border-slate-300 p-3 mb-2 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            <textarea id="macroExpansion" placeholder="Expansion..."
                class="w-full bg-slate-50 border border-slate-300 p-3 mb-2 rounded-md h-40 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"></textarea>
            <div class="flex justify-end gap-3">
                <button onclick="document.getElementById('macroModal').classList.add('hidden')"
                    class="px-4 py-2 text-slate-600 hover:bg-slate-100 rounded-lg">Close</button>
                <button onclick="saveMacro()"
                    class="bg-blue-800 hover:bg-blue-900 text-white px-5 py-2 rounded-lg font-semibold shadow transition">Save</button>
            </div>
            <div id="macroList" class="mt-4 pt-4 border-t border-slate-200 text-xs h-48 overflow-y-auto"></div>
        </div>
    </div>

    <div id="consentModal" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-50 no-print">
        <div class="bg-white rounded-2xl shadow-2xl w-full max-w-md p-6 border border-slate-200">
            <h2 class="text-lg font-bold text-blue-900 mb-2 tracking-tight">Confirm &amp; Proceed</h2>
            <p class="text-sm text-slate-700 mb-4">I understand the prescriptions are generated by Clinova Rx and I
                accept full responsibility for clinical decisions and patient risk.</p>
            <div class="flex justify-end gap-3">
                <button onclick="closeConsent()"
                    class="px-4 py-2 text-slate-600 hover:bg-slate-100 rounded-lg">Cancel</button>
                <button onclick="confirmConsent()"
                    class="px-4 py-2 bg-blue-800 hover:bg-blue-900 text-white rounded-lg font-semibold shadow">Agree
                    &amp; Continue</button>
            </div>
        </div>
    </div>

    <script>
        const getApiBase = () => {
            if (window.location.protocol === 'blob:' || window.location.origin === 'null') {
                return 'http://localhost:3000';
            }
            const host = window.location.hostname;
            if (host === 'localhost' || host === '127.0.0.1') {
                return window.location.port === '3000' ? '' : 'http://localhost:3000';
            }
            return '';
        };
        const API_BASE = getApiBase();
        const socket = API_BASE ? io(API_BASE) : io();

        let mediaRecorder, isRecording = false, transcriptBuffer = "", timerInterval;
        let backupAudioChunks = [];
        let recordedMimeType = ''; // To store the browser's native mime type
        let audioCtx, sourceNode, processorNode, analyserNode, waveformAnim;
        let pcmQueue = [];
        let recordState = 'idle'; // idle | recording | paused | processing
        let elapsedSeconds = 0;
        const MIN_RECORD_SECONDS = 5; // discard shorter clips
        const MAX_RECORD_SECONDS = 300; // 5 minutes max
        let transcriptionMode = 'offline'; // 'live' or 'offline'
        let modeLocked = false;
        let fontMenuOpen = false;
        let reviewEnabled = false;
        let structuredRenderEnabled = true;
        let currentCredits = 0;
        let pendingHtml = "";
        let savedHeaderHtml = "";
        let headerDirty = false;
        let headerStatusTimeout;
        let currentFontFamily = "'Inter', sans-serif";
        let currentFontSize = "14px";
        let consentAction = 'print';
        let testUploadInFlight = false;
        let rxPopoverEl = null;
        let rxActiveTarget = null;
        let rxSuggestResults = [];
        let rxHighlightIndex = -1;
        const RX_SUGGEST_DEBOUNCE_MS = 180;

        function setLoginLoading(isLoading) {
            const overlay = document.getElementById('loginLoading');
            if (overlay) overlay.classList.toggle('hidden', !isLoading);
        }

        function setLoginPending(isPending) {
            const inputs = [document.getElementById('loginPhone'), document.getElementById('loginPass'), document.getElementById('loginButton')];
            inputs.forEach(el => {
                if (!el) return;
                el.disabled = isPending;
                el.classList.toggle('opacity-70', isPending);
                el.classList.toggle('cursor-not-allowed', isPending);
            });
        }

        // --- AUTH ---
        window.onload = initApp;
        async function login() {
            const phone = document.getElementById('loginPhone').value;
            const pass = document.getElementById('loginPass').value;
            setLoginPending(true);
            try {
                const res = await fetch('/api/login', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ phone, password: pass }) });
                const data = await res.json();
                if (data.success) {
                    document.getElementById('loginError').innerText = "";
                    setLoginPending(false);
                    setLoginLoading(true);
                    window.location.href = '/dashboard';
                } else {
                    document.getElementById('loginError').innerText = "Login failed. Check phone/password.";
                    setLoginPending(false);
                }
            } catch (err) {
                document.getElementById('loginError').innerText = "Login failed. Please try again.";
                setLoginPending(false);
            }
        }

        async function autoReview() {
            const html = pendingHtml || document.getElementById('content').innerHTML;
            if (!html || html.trim() === "") {
                updateStatus("No prescription to review", "text-amber-600");
                setRecordState('idle');
                modeLocked = false;
                return;
            }
            updateStatus("AI review in progress‚Ä¶", "text-blue-600");
            try {
                const res = await fetch('/api/review', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ html })
                });
                const data = await res.json();
                if (data.success) {
                    pendingHtml = data.reviewed;
                    updateStatus("Formatting...", "text-blue-600");
                    await autoFormat();
                } else {
                    updateStatus("Review failed", "text-red-500");
                    setRecordState('idle');
                    modeLocked = false;
                }
            } catch (e) {
                updateStatus("Review failed", "text-red-500");
                setRecordState('idle');
                modeLocked = false;
            }
        }
        async function logout() {
            await fetch('/api/logout', { method: 'POST' });
            window.location.href = '/';
        }
        async function initApp() {
            // load client preferences before showing UI
            const savedReview = localStorage.getItem('aiReviewEnabled');
            if (savedReview !== null) {
                setReviewEnabled(savedReview === 'true', true);
            }

            const savedMode = localStorage.getItem('transcriptionMode');
            if (savedMode === 'live' || savedMode === 'offline') {
                setMode(savedMode, true);
            }
            setMode(transcriptionMode, true);
            try {
                const res = await fetch('/api/me');
                if (res.status === 401) throw new Error("Unauthorized");
                const data = await res.json();
                setCreditDisplay(data.credits);
                const headerEl = document.getElementById('docHeader');
                if (headerEl) {
                    headerEl.innerHTML = data.header_html || "<h1>Dr. Name</h1><p>Edit Header...</p>";
                    setHeaderBaseline(headerEl.innerHTML);
                    applyCurrentFontToHeader();
                }
                document.getElementById('loginScreen').classList.add('hidden');
                document.getElementById('appScreen').classList.remove('hidden');
                loadMacros();
                loadSettings(false);
            } catch (e) { }
        }
        async function autoFormat() {
            const html = pendingHtml || document.getElementById('content').innerHTML;
            if (!html || html.trim() === "") {
                updateStatus("No prescription to format", "text-amber-600");
                setRecordState('idle');
                modeLocked = false;
                return;
            }
            try {
                const res = await fetch('/api/format', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ html })
                });
                const data = await res.json();
                if (data.success) {
                    console.log("üß™ format response (client)", {
                        hasStructured: Boolean(data.structured),
                        sectionKeys: data.structured ? Object.keys(data.structured) : [],
                        formattedPreview: (data.formatted || "").slice(0, 120)
                    });

                    // Progressive typing effect
                    updateStatus("Typing...", "text-blue-600");
                    const finalHtml = renderFormattedResult(data);

                    // Clear first
                    document.getElementById('content').innerHTML = "";

                    // Type it out (speed: 10ms per char ~ 6000 chars/min = very fast reading speed)
                    // OpenAI is faster, maybe 5ms? User said "slightly slower than that". 
                    // Let's try 15ms.
                    await typewriterHtml('content', finalHtml, 15);

                    attachRxEditing();
                    pendingHtml = "";
                    updateStatus("DONE", "text-green-600");
                } else {
                    updateStatus("Formatting failed", "text-red-500");
                }
            } catch (e) {
                updateStatus("Formatting failed", "text-red-500");
            } finally {
                setRecordState('done');
                modeLocked = false;
                setTimeout(() => setRecordState('idle'), 1200);
            }
        }

        function triggerTestUpload() {
            if (testUploadInFlight || modeLocked) return;
            const fileInput = document.getElementById('testAudioInput');
            if (fileInput) fileInput.click();
        }

        async function handleTestFile(file) {
            if (!file) return;
            if (testUploadInFlight) return;
            if (currentCredits <= 0) {
                alert("No credits remaining. Please add Rx credits before uploading.");
                return;
            }

            // Immediately close the settings modal so user feels unblocked
            const settingsModal = document.getElementById('settingsModal');
            if (settingsModal) settingsModal.classList.add('hidden');

            testUploadInFlight = true;
            modeLocked = true;
            setRecordState('processing');
            updateStatus("Uploading test clip‚Ä¶", "text-blue-600");

            const btn = document.getElementById('testUploadButton');
            if (btn) {
                btn.disabled = true;
                btn.classList.add('opacity-70', 'cursor-not-allowed');
            }

            try {
                const formData = new FormData();
                formData.append('audio', file);
                formData.append('context', document.getElementById('placeholder') ? "" : document.getElementById('content').innerHTML);

                const res = await fetch('/api/process-backup', { method: 'POST', body: formData });
                const data = await res.json();
                if (!res.ok || !data.success) throw new Error(data.error || "Processing failed");
                handleResult(data);
            } catch (err) {
                updateStatus("Test upload failed", "text-red-500");
                alert(err.message || "Test upload failed");
                setRecordState('idle');
                modeLocked = false;
                // createModal? No just alert above. Use console too.
                console.error(err);
                // Re-open settings if crucial? Probably not, user knows it failed.
            } finally {
                testUploadInFlight = false;
                if (btn) {
                    btn.disabled = false;
                    btn.classList.remove('opacity-70', 'cursor-not-allowed');
                }
                const fileInput = document.getElementById('testAudioInput');
                if (fileInput) fileInput.value = "";
            }
        }
        function setHeaderStatus(text, colorClass = "text-emerald-600") {
            const statusEl = document.getElementById('headerStatus');
            if (!statusEl) return;
            statusEl.innerText = text;
            statusEl.className = `text-xs font-semibold h-4 ${colorClass}`;
            if (headerStatusTimeout) clearTimeout(headerStatusTimeout);
            if (text) headerStatusTimeout = setTimeout(() => { statusEl.innerText = ""; }, 2000);
        }

        function toggleHeaderActions(show) {
            const actions = document.getElementById('headerActions');
            if (!actions) return;
            actions.classList.toggle('hidden', !show);
        }

        function setHeaderBaseline(html) {
            savedHeaderHtml = html || "";
            headerDirty = false;
            toggleHeaderActions(false);
        }

        function markHeaderDirty() {
            const el = document.getElementById('docHeader');
            if (!el) return;
            const isDirty = el.innerHTML.trim() !== (savedHeaderHtml || "").trim();
            headerDirty = isDirty;
            toggleHeaderActions(isDirty);
        }

        function discardHeaderChanges() {
            const el = document.getElementById('docHeader');
            if (!el) return;
            el.innerHTML = savedHeaderHtml || "";
            headerDirty = false;
            toggleHeaderActions(false);
            setHeaderStatus("Changes discarded", "text-slate-500");
        }

        async function saveHeader() {
            const docHeaderEl = document.getElementById('docHeader');
            if (!docHeaderEl) return;
            const html = docHeaderEl.innerHTML;
            try {
                const res = await fetch('/api/header', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ html }) });
                if (!res.ok) throw new Error("Save failed");
                setHeaderStatus("Header saved", "text-emerald-600");
                setHeaderBaseline(html);
            } catch (e) {
                setHeaderStatus("Save failed", "text-rose-600");
            }
        }

        // --- SOCKET EVENTS ---
        socket.on('transcript-update', (data) => {
            if (data.isFinal) {
                transcriptBuffer += " " + data.text;
                document.getElementById('livePreview').innerText = "";
                updateStatus("CAPTURED", "text-blue-600");
            } else {
                document.getElementById('livePreview').innerText = data.text;
                updateStatus("HEARING...", "text-red-500");
            }
        });

        socket.on('prescription-result', (data) => {
            handleResult(data);
        });

        socket.on('use-backup-upload', () => {
            document.getElementById('status').innerText = "USING BACKUP...";
            document.getElementById('status').className = "text-center text-xs text-yellow-600 font-bold mb-4";
            uploadBackup();
        });

        function updateStatus(text, colorClass) {
            const statusEl = document.getElementById('status');
            statusEl.innerText = text;
            statusEl.className = `text-center text-xs font-bold mb-4 min-h-[1.5rem] whitespace-pre-line px-4 ${colorClass || 'text-gray-500'}`;
        }

        function setTimerDisplayText(text) {
            const desktop = document.getElementById('timerDisplay');
            if (desktop) desktop.innerText = text;
        }

        function setCreditDisplay(value) {
            currentCredits = Number(value) || 0;
            const primary = document.getElementById('creditDisplay');
            const secondary = document.getElementById('creditDisplayDesktop');
            if (primary) primary.innerText = value;
            if (secondary) secondary.innerText = value;
        }

        function renderFormattedResult(data) {
            if (structuredRenderEnabled && data.structured) {
                return renderStructuredHtml(data.structured, data.formatted);
            }
            return data.formatted || "";
        }

        function renderStructuredHtml(structured, fallbackHtml = "") {
            if (!structured) return fallbackHtml || "";
            const sections = [];
            const wrapSection = (title, body) => {
                if (!body) return;
                sections.push(`<h3><b>${title}</b></h3><hr>${body}`);
            };

            const safeText = (text) => (text || "").toString().trim();
            const attrSafe = (text = "") => safeText(text).replace(/"/g, '&quot;');
            const normalizeRxRow = (row = {}) => {
                const pick = (...keys) => keys.map(k => row[k]).find(Boolean) || "";
                return {
                    medicine: pick('medicine', 'Medicine', 'drug', 'Drug'),
                    molecule: pick('molecule', 'Molecule', 'salt', 'Salt', 'composition', 'Composition'),
                    dose: pick('dose', 'Dose', 'strength', 'Strength'),
                    frequency: pick('frequency', 'Frequency', 'freq', 'Freq'),
                    duration: pick('duration', 'Duration', 'days', 'Days')
                };
            };

            const patient = safeText(structured.patientDetails);
            wrapSection("Patient details", patient);

            const dx = safeText(structured.diagnosis);
            wrapSection("Diagnosis", dx);

            if (structured.advice && Array.isArray(structured.advice) && structured.advice.length) {
                const items = structured.advice.filter(Boolean).map(item => `<li>${item}</li>`).join('');
                wrapSection("Advice", `<ul>${items}</ul>`);
            }

            if (structured.rx && Array.isArray(structured.rx) && structured.rx.length) {
                const rowHasContent = (row = {}) => {
                    return [row.medicine, row.molecule, row.dose, row.frequency, row.duration].some(v => safeText(v || ""));
                };
                const rows = structured.rx.map(normalizeRxRow).filter(rowHasContent).map(row => {
                    const m = safeText(row.medicine);
                    const mol = safeText(row.molecule);
                    const mol1 = safeText(row.mol1 || row.molecule);
                    const mol2 = safeText(row.mol2 || "");
                    const molDisplay = [mol1, mol2].filter(Boolean).join(' + ') || mol;
                    const dose = safeText(row.dose);
                    const freq = safeText(row.frequency);
                    const dur = safeText(row.duration);
                    const cellStyle = "border:1px solid #cbd5e1; padding:6px; text-align:left;";
                    return `<tr class="rx-row"><td style="${cellStyle}"><span tabindex="0" class="rx-medicine underline decoration-dotted decoration-slate-400" data-mol1="${attrSafe(mol1)}" data-mol2="${attrSafe(mol2)}" data-id="">${m || 'Tap to edit'}</span></td><td class="rx-molecule-cell" style="${cellStyle}">${molDisplay}</td><td style="${cellStyle}">${dose}</td><td style="${cellStyle}">${freq}</td><td style="${cellStyle}">${dur}</td></tr>`;
                }).join('');
                if (rows) {
                    const headCell = "border:1px solid #cbd5e1; padding:6px; text-align:left; font-weight:700;";
                    const table = `
                    <table style="width:100%; border:1px solid #cbd5e1; border-collapse:collapse;">
                        <thead>
                            <tr>
                                <th style="${headCell}">Medicine</th>
                                <th style="${headCell}">Molecule(s)</th>
                                <th style="${headCell}">Dose</th>
                                <th style="${headCell}">Frequency</th>
                                <th style="${headCell}">Duration</th>
                            </tr>
                        </thead>
                        <tbody>${rows}</tbody>
                    </table>`;
                    wrapSection("Rx", table);
                }
            }

            if (!sections.length) return fallbackHtml || "";
            return sections.join('\n');
        }

        function debounce(fn, delay = 150) {
            let t;
            return (...args) => {
                clearTimeout(t);
                t = setTimeout(() => fn(...args), delay);
            };
        }

        const debouncedRxSuggest = debounce(async (value, listEl) => {
            await loadRxSuggestions(value, listEl);
        }, RX_SUGGEST_DEBOUNCE_MS);

        function attachRxEditing() {
            const meds = document.querySelectorAll('.rx-medicine');
            meds.forEach(el => {
                el.classList.add('hover:text-blue-700');
                el.title = "Click to edit medicine name";
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    openRxPopover(el);
                });
                el.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        openRxPopover(el);
                    }
                });
            });
        }

        function closeRxPopover() {
            if (rxPopoverEl && rxPopoverEl.parentNode) {
                rxPopoverEl.parentNode.removeChild(rxPopoverEl);
            }
            rxPopoverEl = null;
            rxActiveTarget = null;
            rxSuggestResults = [];
            rxHighlightIndex = -1;
        }

        function positionRxPopover(pop, target) {
            const rect = target.getBoundingClientRect();
            pop.style.top = `${rect.bottom + window.scrollY + 6}px`;
            pop.style.left = `${rect.left + window.scrollX}px`;
        }

        async function fetchMedicineSuggest(q) {
            const res = await fetch(`/api/medicine-suggest?q=${encodeURIComponent(q)}`);
            if (!res.ok) throw new Error('suggest failed');
            return res.json();
        }

        async function fetchMedicineValidate(q) {
            const res = await fetch(`/api/medicine-validate?q=${encodeURIComponent(q)}`);
            if (!res.ok) throw new Error('validate failed');
            return res.json();
        }

        function renderRxSuggestions(listEl) {
            if (!rxSuggestResults.length) {
                listEl.innerHTML = '<div class="rx-empty">No results</div>';
                rxHighlightIndex = -1;
                return;
            }
            listEl.innerHTML = '';
            rxSuggestResults.forEach((sugg, idx) => {
                const div = document.createElement('div');
                div.className = 'rx-suggestion' + (idx === rxHighlightIndex ? ' active' : '');
                const molecules = [sugg.mol1, sugg.mol2].filter(Boolean).join(' ‚Ä¢ ') || (sugg.composition || '');
                div.innerHTML = `
                    <div class="name">${sugg.brand}</div>
                    <div class="molecules">${molecules || 'No molecule info'}</div>
                    <div class="meta">${sugg.manufacturer || ''}</div>
                `;
                div.addEventListener('mouseenter', () => {
                    rxHighlightIndex = idx;
                    syncRxHighlight(listEl);
                });
                div.addEventListener('click', () => {
                    if (rxActiveTarget) applyRxSuggestion(rxActiveTarget, sugg);
                });
                listEl.appendChild(div);
            });
            rxHighlightIndex = 0;
            syncRxHighlight(listEl);
        }

        function syncRxHighlight(listEl) {
            [...listEl.children].forEach((child, i) => {
                child.classList.toggle('active', i === rxHighlightIndex);
            });
        }

        async function loadRxSuggestions(value, listEl) {
            const q = (value || "").trim();
            if (!q) {
                listEl.innerHTML = '<div class="rx-empty">Start typing to see matches</div>';
                rxSuggestResults = [];
                rxHighlightIndex = -1;
                return;
            }
            listEl.innerHTML = '<div class="rx-empty">Searching‚Ä¶</div>';
            try {
                rxSuggestResults = await fetchMedicineSuggest(q);
                renderRxSuggestions(listEl);
            } catch (err) {
                listEl.innerHTML = '<div class="rx-empty">Could not fetch suggestions</div>';
                rxSuggestResults = [];
                rxHighlightIndex = -1;
            }
        }

        function applyRxSuggestion(target, suggestion) {
            if (!target) return;
            target.textContent = suggestion.brand || target.textContent;
            target.dataset.id = suggestion.id || "";
            target.dataset.mol1 = suggestion.mol1 || "";
            target.dataset.mol2 = suggestion.mol2 || "";
            const row = target.closest('tr');
            const moleculeCell = row ? row.querySelector('.rx-molecule-cell') : null;
            const moleculeText = [suggestion.mol1, suggestion.mol2].filter(Boolean).join(' + ') || suggestion.composition || "";
            if (moleculeCell) moleculeCell.textContent = moleculeText || '‚Äî';
            closeRxPopover();
        }

        async function openRxPopover(target) {
            closeRxPopover();
            rxActiveTarget = target;
            const pop = document.createElement('div');
            pop.className = 'rx-popover';
            pop.innerHTML = `
                <input type="text" aria-label="Edit medicine name" value="${(target.textContent || '').trim()}">
                <div class="rx-suggestions"><div class="rx-empty">Start typing to see matches</div></div>
                <div class="rx-foot"><span class="rx-pill">Typeahead</span><span>Enter to select ‚Ä¢ Esc to close</span></div>
            `;
            document.body.appendChild(pop);
            rxPopoverEl = pop;
            positionRxPopover(pop, target);

            const input = pop.querySelector('input');
            const listEl = pop.querySelector('.rx-suggestions');

            input.addEventListener('input', (e) => debouncedRxSuggest(e.target.value, listEl));
            input.addEventListener('keydown', async (e) => {
                if (e.key === 'Escape') {
                    closeRxPopover();
                    return;
                }
                if (e.key === 'ArrowDown') {
                    if (!rxSuggestResults.length) return;
                    rxHighlightIndex = (rxHighlightIndex + 1) % rxSuggestResults.length;
                    syncRxHighlight(listEl);
                    e.preventDefault();
                }
                if (e.key === 'ArrowUp') {
                    if (!rxSuggestResults.length) return;
                    rxHighlightIndex = (rxHighlightIndex - 1 + rxSuggestResults.length) % rxSuggestResults.length;
                    syncRxHighlight(listEl);
                    e.preventDefault();
                }
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (rxHighlightIndex >= 0 && rxSuggestResults[rxHighlightIndex]) {
                        applyRxSuggestion(target, rxSuggestResults[rxHighlightIndex]);
                        return;
                    }
                    try {
                        const best = await fetchMedicineValidate(e.target.value);
                        if (best && best.brand) applyRxSuggestion(target, best);
                        else closeRxPopover();
                    } catch (err) {
                        closeRxPopover();
                    }
                }
            });

            debouncedRxSuggest(input.value, listEl);
            input.focus();
            input.select();
        }

        document.addEventListener('click', (e) => {
            if (rxPopoverEl && !rxPopoverEl.contains(e.target) && (!rxActiveTarget || !rxActiveTarget.contains(e.target))) {
                closeRxPopover();
            }
        });

        window.addEventListener('resize', () => {
            if (rxPopoverEl && rxActiveTarget) positionRxPopover(rxPopoverEl, rxActiveTarget);
        });
        window.addEventListener('scroll', () => {
            if (rxPopoverEl && rxActiveTarget) positionRxPopover(rxPopoverEl, rxActiveTarget);
        }, true);

        function setMode(mode, skipPersist = false) {
            transcriptionMode = mode;
            const label = document.getElementById('modeLabel');
            const checkLive = document.getElementById('checkLive');
            const checkOffline = document.getElementById('checkOffline');
            if (mode === 'live') {
                updateStatus("READY (Live)", "text-gray-500");
                label.innerText = "‚ö° Live (Faster)";
                checkLive.classList.remove('hidden');
                checkOffline.classList.add('hidden');
            } else {
                updateStatus("READY (Offline high accuracy)", "text-gray-500");
                label.innerText = "üîç Offline (High Accuracy)";
                checkOffline.classList.remove('hidden');
                checkLive.classList.add('hidden');
            }
            closeModeMenu();
            if (!skipPersist) localStorage.setItem('transcriptionMode', transcriptionMode);
        }



        function toggleModeMenu() {
            if (modeLocked) return;
            const menu = document.getElementById('modeMenu');
            menu.classList.toggle('hidden');
        }

        function closeModeMenu() {
            const menu = document.getElementById('modeMenu');
            if (menu) menu.classList.add('hidden');
        }

        function selectMode(mode) {
            if (modeLocked) return;
            setMode(mode);
        }

        function toggleFontMenu() {
            const menu = document.getElementById('fontMenu');
            fontMenuOpen = !fontMenuOpen;
            if (fontMenuOpen) {
                syncFontControls();
                menu.classList.remove('hidden');
            } else {
                menu.classList.add('hidden');
            }
        }

        function closeFontMenu() {
            const menu = document.getElementById('fontMenu');
            if (menu) {
                menu.classList.add('hidden');
                fontMenuOpen = false;
            }
        }

        const normalizeFont = (val) => (val || "").toLowerCase().replace(/["']/g, '').replace(/\s+/g, '');

        function syncFontControls() {
            const content = document.getElementById('content');
            if (!content) return;
            const style = window.getComputedStyle(content);
            currentFontFamily = style.fontFamily;
            currentFontSize = style.fontSize;
            const familySelect = document.getElementById('fontFamilySelect');
            const sizeSelect = document.getElementById('fontSizeSelect');
            if (familySelect) {
                const normalizedFamily = normalizeFont(currentFontFamily);
                const match = Array.from(familySelect.options).find(opt => normalizeFont(opt.value) === normalizedFamily);
                familySelect.value = match ? match.value : familySelect.options[0].value;
            }
            if (sizeSelect) {
                const matchSize = Array.from(sizeSelect.options).find(opt => opt.value === currentFontSize);
                sizeSelect.value = matchSize ? matchSize.value : sizeSelect.options[0].value;
            }
            applyCurrentFontToHeader(style);
        }

        function applyFontSettings() {
            const family = document.getElementById('fontFamilySelect').value;
            const size = document.getElementById('fontSizeSelect').value;
            currentFontFamily = family;
            currentFontSize = size;
            document.getElementById('content').style.fontFamily = family;
            document.getElementById('content').style.fontSize = size;
            document.getElementById('docHeader').style.fontFamily = family;
            document.getElementById('docHeader').style.fontSize = size;
            closeFontMenu();
        }

        function applySelectedFontDefaults() {
            const familySelect = document.getElementById('fontFamilySelect');
            const sizeSelect = document.getElementById('fontSizeSelect');
            if (!familySelect || !sizeSelect) return;
            currentFontFamily = familySelect.value;
            currentFontSize = sizeSelect.value;
            const content = document.getElementById('content');
            const header = document.getElementById('docHeader');
            if (content) {
                content.style.fontFamily = currentFontFamily;
                content.style.fontSize = currentFontSize;
            }
            if (header) {
                header.style.fontFamily = currentFontFamily;
                header.style.fontSize = currentFontSize;
            }
        }

        function applyCurrentFontToHeader(styleObj) {
            const content = document.getElementById('content');
            const header = document.getElementById('docHeader');
            if (!content || !header) return;
            const style = styleObj || window.getComputedStyle(content);
            header.style.fontFamily = style.fontFamily;
            header.style.fontSize = style.fontSize;
            header.style.lineHeight = style.lineHeight;
        }

        function setReviewEnabled(value, skipPersist = false) {
            reviewEnabled = value;
            const toggle = document.getElementById('reviewToggle');
            if (toggle) toggle.checked = reviewEnabled;

            const knobs = [document.getElementById('aiToggleKnob'), document.getElementById('aiToggleKnobMobile')].filter(Boolean);
            const labels = [document.getElementById('aiToggleLabel'), document.getElementById('aiToggleLabelMobile')].filter(Boolean);
            const wraps = [document.getElementById('aiReviewToggle'), document.getElementById('aiReviewToggleMobile')].filter(Boolean);
            const tracks = [document.getElementById('aiToggleTrack'), document.getElementById('aiToggleTrackMobile')].filter(Boolean);

            knobs.forEach(knob => {
                knob.style.transform = reviewEnabled ? 'translateX(24px)' : 'translateX(0px)';
                knob.className = `absolute top-0.5 left-0.5 w-5 h-5 rounded-full bg-white shadow transition-transform duration-200`;
            });
            labels.forEach(label => {
                label.innerText = reviewEnabled ? "Enabled" : "Disabled";
                label.className = `text-sm font-semibold ${reviewEnabled ? 'text-blue-900' : 'text-slate-500'}`;
            });
            wraps.forEach(wrap => {
                wrap.classList.toggle('ring-2', reviewEnabled);
                wrap.classList.toggle('ring-green-200', reviewEnabled);
                wrap.classList.toggle('bg-green-50', reviewEnabled);
            });
            tracks.forEach(track => {
                track.className = `w-12 h-6 rounded-full transition relative overflow-hidden ${reviewEnabled ? 'bg-green-500' : 'bg-slate-200'}`;
            });
            if (!skipPersist) localStorage.setItem('aiReviewEnabled', reviewEnabled ? 'true' : 'false');
        }

        function toggleReviewSetting() {
            if (isRecording || recordState === 'processing') {
                const toggle = document.getElementById('reviewToggle');
                if (toggle) toggle.checked = reviewEnabled;
                return;
            }
            setReviewEnabled(!reviewEnabled);
        }

        function handleAiToggleClick() {
            if (isRecording || recordState === 'processing') return;
            setReviewEnabled(!reviewEnabled);
        }

        const setFabIcon = (mode) => {
            const icon = document.getElementById('recordIcon');
            if (!icon) return;
            icon.setAttribute('viewBox', '0 0 24 24');
            const baseClass = "w-7 h-7";
            const icons = {
                mic: `<path d="M12 14a3 3 0 0 0 3-3V7a3 3 0 1 0-6 0v4a3 3 0 0 0 3 3Z"/><path d="M7 11a5 5 0 0 0 10 0h-1.5a3.5 3.5 0 0 1-7 0H7Z"/><path d="M12 17v3m0 0h-3m3 0h3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>`,
                pause: `<path d="M7 5h4v14H7zM13 5h4v14h-4z"/>`,
                play: `<path d="M8 5v14l11-7z"/>`,
                check: `<path d="M9 12l2 2 4-4" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>`,
            };
            icon.className = baseClass;
            if (mode === 'spinner') {
                icon.className = "w-7 h-7 text-white animate-pulse";
                icon.innerHTML = `<svg class="w-7 h-7" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M7 2h10a1 1 0 0 1 1 1v1.2a3 3 0 0 1-.88 2.12L14 9l3.12 2.68A3 3 0 0 1 18 13.8V15a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1v-1.2a3 3 0 0 1 .88-2.12L10 9 6.88 6.32A3 3 0 0 1 6 4.2V3a1 1 0 0 1 1-1Z"/>
                    <path d="M10 3h4" />
                    <path d="M10 21h4" />
                </svg>`;
            } else if (mode === 'mic') {
                icon.innerHTML = icons.mic;
            } else if (mode === 'pause') {
                icon.innerHTML = icons.pause;
            } else if (mode === 'play') {
                icon.innerHTML = icons.play;
            } else if (mode === 'check') {
                icon.innerHTML = icons.check;
            } else {
                icon.innerHTML = icons.mic;
            }
        };

        function setRecordState(state) {
            recordState = state;
            const fab = document.getElementById('recordFab');
            const label = document.getElementById('recordLabel');
            const wave = document.getElementById('waveform');
            const stopBtn = document.getElementById('stopButton');

            if (state === 'idle') {
                fab.className = "w-16 h-16 rounded-full bg-red-600 text-white shadow-lg flex items-center justify-center transition-all active:scale-95";
                setFabIcon('mic');
                label.innerText = "Tap to start prescription";
                wave.classList.add('opacity-0');
                if (stopBtn) stopBtn.classList.add('hidden');
                setTimerDisplayText("00:00");
            } else if (state === 'recording') {
                fab.className = "w-16 h-16 rounded-full bg-red-600 text-white shadow-lg flex items-center justify-center transition-all scale-105 animate-pulse";
                setFabIcon('pause');
                label.innerText = "Recording... Tap to pause";
                wave.classList.remove('opacity-0');
                if (stopBtn) stopBtn.classList.remove('hidden');
            } else if (state === 'paused') {
                fab.className = "w-16 h-16 rounded-full bg-amber-500 text-white shadow-lg flex items-center justify-center transition-all";
                setFabIcon('play');
                label.innerText = "Paused. Tap to resume";
                wave.classList.add('opacity-0');
                if (stopBtn) stopBtn.classList.remove('hidden');
            } else if (state === 'processing') {
                fab.className = "w-16 h-16 rounded-full bg-blue-600 text-white shadow-lg flex items-center justify-center transition-all animate-pulse";
                setFabIcon('spinner');
                label.innerText = "Processing...";
                wave.classList.add('opacity-0');
                if (stopBtn) stopBtn.classList.add('hidden');
            } else if (state === 'done') {
                fab.className = "w-16 h-16 rounded-full bg-green-600 text-white shadow-lg flex items-center justify-center transition-all";
                setFabIcon('check');
                label.innerText = "Done";
                wave.classList.add('opacity-0');
                if (stopBtn) stopBtn.classList.add('hidden');
            }
        }

        function startWaveform() {
            const canvas = document.getElementById('waveform');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            if (!analyserNode) return;
            const drawLive = () => {
                analyserNode.getByteTimeDomainData(dataArray);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "rgba(23,105,170,0.08)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = "#1769AA";
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                const sliceWidth = canvas.width / dataArray.length;
                let x = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = (v * canvas.height) / 2;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                    x += sliceWidth;
                }
                ctx.stroke();
                waveformAnim = requestAnimationFrame(drawLive);
            };
            if (waveformAnim) cancelAnimationFrame(waveformAnim);
            analyserNode.fftSize = 128;
            var dataArray = new Uint8Array(analyserNode.frequencyBinCount);
            waveformAnim = requestAnimationFrame(drawLive);
            canvas.classList.remove('opacity-0');
        }

        function stopWaveform() {
            if (waveformAnim) cancelAnimationFrame(waveformAnim);
            waveformAnim = null;
            const canvas = document.getElementById('waveform');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            canvas.classList.add('opacity-0');
        }

        function flushPcmQueue() {
            if (!pcmQueue.length) return;
            const totalSamples = pcmQueue.reduce((sum, chunk) => sum + chunk.length, 0);
            const merged = new Int16Array(totalSamples);
            let offset = 0;
            pcmQueue.forEach(chunk => { merged.set(chunk, offset); offset += chunk.length; });
            pcmQueue = [];
            socket.emit('audio-stream', { type: 'pcm', data: merged.buffer });
        }

        function handleResult(data) {
            if (timerInterval) clearInterval(timerInterval);
            elapsedSeconds = 0;
            setTimerDisplayText("00:00");
            document.getElementById('countdownBadge').classList.add('hidden');
            stopWaveform();
            if (data.success) {
                setCreditDisplay(data.credits);
                pendingHtml = data.html;
                if (reviewEnabled) {
                    updateStatus("AI review in progress‚Ä¶", "text-blue-600");
                    autoReview();
                } else {
                    updateStatus("Formatting...", "text-blue-600");
                    autoFormat();
                }
            } else {
                alert(data.error);
                updateStatus("ERROR", "text-red-500");
                setRecordState('idle');
                modeLocked = false;
            }
        }

        // --- RECORDING (Native Streaming) ---
        async function startRecording() {
            if (isRecording || recordState === 'processing') return;
            if (currentCredits <= 0) {
                updateStatus("No credits remaining. Please add Rx credits.", "text-red-500");
                return;
            }
            transcriptBuffer = "";
            backupAudioChunks = [];
            elapsedSeconds = 0;
            setTimerDisplayText("00:00");

            try {
                // Audio constraints: 16kHz mono is sufficient for speech and reduces raw size before encoding
                const constraints = {
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        channelCount: 1,
                        sampleRate: 16000
                    }
                };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);

                if (transcriptionMode === 'live') {
                    // Live stream via AudioContext (16k PCM)
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                    sourceNode = audioCtx.createMediaStreamSource(stream);
                    analyserNode = audioCtx.createAnalyser();
                    analyserNode.fftSize = 512;
                    processorNode = audioCtx.createScriptProcessor(4096, 1, 1);
                    sourceNode.connect(analyserNode);
                    analyserNode.connect(processorNode);
                    processorNode.connect(audioCtx.destination);

                    processorNode.onaudioprocess = (e) => {
                        if (!isRecording) return;
                        const input = e.inputBuffer.getChannelData(0);
                        const pcm16 = new Int16Array(input.length);
                        for (let i = 0; i < input.length; i++) {
                            let s = Math.max(-1, Math.min(1, input[i]));
                            pcm16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                        }
                        pcmQueue.push(pcm16);
                        const totalSamples = pcmQueue.reduce((sum, chunk) => sum + chunk.length, 0);
                        if (totalSamples >= 12000) { // ~0.75s
                            const merged = new Int16Array(totalSamples);
                            let offset = 0;
                            pcmQueue.forEach(chunk => { merged.set(chunk, offset); offset += chunk.length; });
                            pcmQueue = [];
                            socket.emit('audio-stream', { type: 'pcm', data: merged.buffer });
                        }
                    };
                } else {
                    // Offline: still create analyser for waveform visualization
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    sourceNode = audioCtx.createMediaStreamSource(stream);
                    analyserNode = audioCtx.createAnalyser();
                    analyserNode.fftSize = 512;
                    sourceNode.connect(analyserNode);
                }

                // Always capture backup/primary recording for final upload
                // Compress to 32kbps Opus (speech optimized) to save 50-70% bandwidth/storage
                const videoBits = 2500000; // ignore, audio only
                const options = {
                    mimeType: 'audio/webm;codecs=opus',
                    audioBitsPerSecond: 32000
                };

                // Safari fallback? Safari supports audioBitsPerSecond in recent versions.
                try {
                    mediaRecorder = new MediaRecorder(stream, options);
                } catch (e) {
                    console.warn("32kbps not supported, falling back to default", e);
                    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });
                }

                recordedMimeType = mediaRecorder.mimeType;
                mediaRecorder.ondataavailable = async (e) => {
                    if (e.data.size > 0) backupAudioChunks.push(e.data);
                };
                mediaRecorder.start(1500);

                isRecording = true;
                setRecordState('recording');
                updateStatus(transcriptionMode === 'live' ? "LISTENING..." : "RECORDING (offline high accuracy)", "text-red-500");
                modeLocked = true;
                startTimer(true);
                startWaveform();

            } catch (e) {
                updateStatus("Mic permission denied", "text-red-500");
                setRecordState('idle');
                modeLocked = false;
            }
        }

        function pauseRecording() {
            if (recordState !== 'recording') return;
            isRecording = false;
            clearInterval(timerInterval);
            try { if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.pause(); } catch (_) { }
            try { if (audioCtx) audioCtx.suspend(); } catch (_) { }
            setRecordState('paused');
            stopWaveform();
            updateStatus("Paused", "text-amber-600");
        }

        function resumeRecording() {
            if (recordState !== 'paused') return;
            isRecording = true;
            try { if (mediaRecorder && mediaRecorder.state === 'paused') mediaRecorder.resume(); } catch (_) { }
            try { if (audioCtx) audioCtx.resume(); } catch (_) { }
            setRecordState('recording');
            startTimer(false);
            startWaveform();
            updateStatus(transcriptionMode === 'live' ? "LISTENING..." : "RECORDING (offline high accuracy)", "text-red-500");
        }

        function handleRecordAction() {
            if (recordState === 'idle' || recordState === 'done') startRecording();
            else if (recordState === 'recording') pauseRecording();
            else if (recordState === 'paused') resumeRecording();
        }

        function handleStopAction() {
            stopRecording();
        }

        function stopRecording() {
            if (recordState === 'idle' || recordState === 'processing') return;
            isRecording = false;
            clearInterval(timerInterval);
            setRecordState('processing');
            document.getElementById('countdownBadge').classList.add('hidden');

            if (transcriptionMode === 'live') {
                flushPcmQueue();
                if (processorNode) { processorNode.disconnect(); processorNode.onaudioprocess = null; processorNode = null; }
                pcmQueue = [];
            }

            if (sourceNode) { try { sourceNode.disconnect(); } catch (_) { } sourceNode = null; }
            if (analyserNode) { analyserNode = null; }
            if (audioCtx) { try { audioCtx.close(); } catch (_) { } audioCtx = null; }
            stopWaveform();

            if (mediaRecorder) {
                try { mediaRecorder.stop(); } catch (_) { }
            }
            if (mediaRecorder && mediaRecorder.stream) mediaRecorder.stream.getTracks().forEach(t => t.stop());

            const recordedSeconds = elapsedSeconds;
            if (recordedSeconds < MIN_RECORD_SECONDS) {
                updateStatus("Discarded (<5s)", "text-gray-500");
                setRecordState('idle');
                modeLocked = false;
                backupAudioChunks = [];
                transcriptBuffer = "";
                return;
            }

            if (transcriptionMode === 'live') {
                updateStatus("FORMATTING...", "text-blue-600");
                const cleanContext = document.getElementById('placeholder') ? "" : document.getElementById('content').innerHTML;
                const pendingPreview = document.getElementById('livePreview').innerText;
                const fullText = (transcriptBuffer + " " + pendingPreview).trim();

                setTimeout(() => {
                    socket.emit('finalize-prescription', { fullTranscript: fullText, context: cleanContext });
                }, 2500);
            } else {
                updateStatus("Processing (offline high accuracy)...", "text-blue-600");
                uploadBackup();
            }
        }

        // --- BACKUP UPLOAD ---
        async function uploadBackup() {
            if (currentCredits <= 0) {
                alert("No credits remaining. Please add Rx credits before uploading.");
                setRecordState('idle');
                modeLocked = false;
                return;
            }
            const blob = new Blob(backupAudioChunks, { type: recordedMimeType });
            try {
                // 1. Get presigned URL
                const upRes = await fetch('/api/upload-url', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contentType: recordedMimeType || 'audio/webm' })
                });
                if (!upRes.ok) throw new Error(`Upload URL failed: ${upRes.status}`);
                const upData = await upRes.json();

                // 2. Upload to S3
                const putRes = await fetch(upData.url, {
                    method: 'PUT',
                    headers: { 'Content-Type': recordedMimeType || 'audio/webm' },
                    body: blob
                });
                if (!putRes.ok) throw new Error(`S3 upload failed: ${putRes.status}`);

                // 3. Process from S3
                const procRes = await fetch('/api/process-s3', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ key: upData.key, context: document.getElementById('placeholder') ? "" : document.getElementById('content').innerHTML })
                });
                if (!procRes.ok) throw new Error(`Backup failed: ${procRes.status}`);
                const data = await procRes.json();
                handleResult(data);
            } catch (e) {
                alert("Backup Upload Failed: " + e.message);
                updateStatus("Backup upload failed", "text-red-500");
                setRecordState('idle');
                modeLocked = false;
            }
        }

        function handlePrint() {
            consentAction = 'print';
            document.getElementById('consentModal').classList.remove('hidden');
        }

        function closeConsent() {
            document.getElementById('consentModal').classList.add('hidden');
        }

        function handleCopy() {
            consentAction = 'copy';
            document.getElementById('consentModal').classList.remove('hidden');
        }

        async function confirmConsent() {
            document.getElementById('consentModal').classList.add('hidden');
            if (consentAction === 'copy') {
                const success = await copyPrescription();
                if (success) updateStatus("Prescription copied", "text-green-600");
            } else {
                window.print();
            }
        }

        async function copyPrescription() {
            try {
                const content = document.getElementById('content');
                if (!content) return false;
                const text = content.innerText || "";
                if (!text.trim()) return false;
                await navigator.clipboard.writeText(text.trim());
                return true;
            } catch (_) {
                return false;
            }
        }

        function handleClear() {
            isRecording = false;
            modeLocked = false;
            if (timerInterval) clearInterval(timerInterval);
            elapsedSeconds = 0;
            transcriptBuffer = "";
            pendingHtml = "";
            backupAudioChunks = [];
            pcmQueue = [];
            setRecordState('idle');
            setTimerDisplayText("00:00");
            const badge = document.getElementById('countdownBadge');
            if (badge) badge.classList.add('hidden');
            const livePreview = document.getElementById('livePreview');
            if (livePreview) livePreview.innerText = "";
            const content = document.getElementById('content');
            if (content) content.innerHTML = '<p id="placeholder" class="text-slate-300 italic no-print">Tap to start prescription...</p>';
            updateStatus("READY", "text-gray-500");
        }


        function startTimer(reset = false) {
            const badge = document.getElementById('countdownBadge');
            if (reset) {
                elapsedSeconds = 0;
                setTimerDisplayText("00:00");
                badge.classList.add('hidden'); // Ensure hidden on reset
            }
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                elapsedSeconds++;

                // Max duration check
                if (elapsedSeconds >= MAX_RECORD_SECONDS) {
                    stopRecording();
                    alert("Maximum recording limit (5 minutes) reached.");
                    return;
                }

                // Show remaining time when nearing limit (last 60s)
                const remaining = MAX_RECORD_SECONDS - elapsedSeconds;
                if (remaining <= 60) {
                    badge.classList.remove('hidden');
                    const rm = Math.floor(remaining / 60);
                    const rs = remaining % 60;
                    badge.innerText = `Time left: ${rm}:${rs.toString().padStart(2, '0')}`;
                    // Pulse red if very close
                    if (remaining <= 10) badge.className = "text-xs font-semibold text-rose-600 bg-rose-100 px-2 py-1 rounded-full text-center animate-pulse";
                    else badge.className = "text-xs font-semibold text-amber-600 bg-amber-100 px-2 py-1 rounded-full text-center";
                } else {
                    badge.classList.add('hidden');
                }

                const m = Math.floor(elapsedSeconds / 60);
                const s = elapsedSeconds % 60;
                setTimerDisplayText(`${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`);
            }, 1000);
        }

        // Events
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('modeMenu');
            const btn = document.getElementById('modeButton');
            if (!menu || !btn) return;
            if (!menu.classList.contains('hidden') && !menu.contains(e.target) && !btn.contains(e.target)) {
                closeModeMenu();
            }
            const fMenu = document.getElementById('fontMenu');
            const fBtn = document.getElementById('fontButton');
            if (fMenu && fBtn && !fMenu.classList.contains('hidden') && !fMenu.contains(e.target) && !fBtn.contains(e.target)) {
                closeFontMenu();
            }
        });

        // Settings & Macros
        function setSettingsStatus(text = "", colorClass = "text-emerald-600") {
            const el = document.getElementById('settingsStatus');
            if (!el) return;
            el.textContent = text;
            el.className = `text-xs h-4 font-semibold ${colorClass}`;
        }

        async function loadSettings(openModal = false) {
            try {
                setSettingsStatus(openModal ? "Loading..." : "", "text-slate-600");
                const res = await fetch('/settings');
                if (!res.ok) throw new Error("Failed");
                const data = await res.json();
                document.getElementById('in_name').value = data.doctor_name || "";
                document.getElementById('in_qual').value = data.qualification || "";
                document.getElementById('in_reg').value = data.reg_no || "";
                document.getElementById('in_clinic').value = data.clinic_details || "";
                document.getElementById('in_keywords').value = data.custom_keywords || "";
                if (openModal) {
                    document.getElementById('settingsModal').classList.remove('hidden');
                    setSettingsStatus("");
                }
            } catch (e) {
                console.error('Load settings error', e);
                setSettingsStatus("Unable to load settings", "text-rose-600");
            }
        }

        async function saveSettings() {
            try {
                setSettingsStatus("Saving...", "text-slate-600");
                const payload = {
                    doctor_name: document.getElementById('in_name').value,
                    qualification: document.getElementById('in_qual').value,
                    reg_no: document.getElementById('in_reg').value,
                    clinic_details: document.getElementById('in_clinic').value,
                    custom_keywords: document.getElementById('in_keywords').value
                };
                const res = await fetch('/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!res.ok) throw new Error("Save failed");
                setSettingsStatus("Saved", "text-emerald-600");
                setTimeout(() => setSettingsStatus(""), 1500);
            } catch (e) {
                console.error('Save settings error', e);
                setSettingsStatus("Failed to save", "text-rose-600");
            }
        }

        function openSettings() { loadSettings(true); }
        function openMacros() {
            document.getElementById('macroModal').classList.remove('hidden');
            loadMacros();
        }
        async function loadMacros() {
            const res = await fetch('/api/macros');
            const data = await res.json();
            document.getElementById('macroList').innerHTML = data.map(m => `
                <div class="border-b py-2 flex justify-between items-start gap-2">
                    <div>
                        <div class="font-semibold text-gray-800">${m.trigger_phrase}</div>
                        <div class="text-gray-600 text-[11px] whitespace-pre-line">${m.expansion}</div>
                    </div>
                    <div class="flex flex-col gap-1">
                        <button class="text-blue-600 text-[11px] underline" onclick="editMacro('${m.trigger_phrase.replace(/'/g, "\\'")}','${m.expansion.replace(/'/g, "\\'")}')">Edit</button>
                        <button class="text-red-600 text-[11px] underline" onclick="deleteMacro('${m.trigger_phrase.replace(/'/g, "\\'")}')">Delete</button>
                    </div>
                </div>`).join('');
        }
        async function saveMacro() {
            await fetch('/api/macros', {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ trigger: document.getElementById('macroTrigger').value, expansion: document.getElementById('macroExpansion').value })
            });
            document.getElementById('macroTrigger').value = ''; document.getElementById('macroExpansion').value = '';
            loadMacros();
        }
        function editMacro(trigger, expansion) {
            document.getElementById('macroTrigger').value = trigger;
            document.getElementById('macroExpansion').value = expansion;
        }
        async function deleteMacro(trigger) {
            await fetch('/api/macros/delete', {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ trigger })
            });
            loadMacros();
        }

        const docHeaderEl = document.getElementById('docHeader');
        if (docHeaderEl) {
            setHeaderBaseline(docHeaderEl.innerHTML);
            docHeaderEl.addEventListener('input', markHeaderDirty);
        }

        applySelectedFontDefaults();
        syncFontControls();
        applyCurrentFontToHeader();
        setReviewEnabled(reviewEnabled);
        setRecordState('idle');

        async function typewriterHtml(elementId, htmlContent, speed = 10) {
            const container = document.getElementById(elementId);
            if (!container) return;

            // Clear current content
            container.innerHTML = '';

            // Parse the new HTML
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');
            const nodes = Array.from(doc.body.childNodes);

            // Helper to recursively type nodes
            async function typeNode(node, parentEl) {
                if (node.nodeType === Node.TEXT_NODE) {
                    const text = node.textContent;
                    if (!text.trim()) {
                        parentEl.appendChild(document.createTextNode(text));
                        return;
                    }
                    const textNode = document.createTextNode('');
                    parentEl.appendChild(textNode);

                    // Split by words to speed up but keep flow, or chars for smoothness
                    // "Slightly slower than OpenAI" -> OpenAI is token based (chunks of ~4 chars).
                    // Let's do huge chunks if it's a table to avoid layout shifts? 
                    // No, table cells are small.
                    // Let's do character based with punctuation pause.

                    const chars = text.split('');
                    for (let i = 0; i < chars.length; i++) {
                        textNode.textContent += chars[i];
                        // Scroll to bottom if needed?
                        // parentEl.scrollIntoView({ behavior: 'smooth', block: 'end' });

                        // Basic delay
                        await new Promise(r => setTimeout(r, speed));
                    }
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    // Clone element without children
                    const clone = node.cloneNode(false);
                    parentEl.appendChild(clone);

                    // Recurse for children
                    const children = Array.from(node.childNodes);
                    for (const child of children) {
                        await typeNode(child, clone);
                    }
                }
            }

            for (const node of nodes) {
                await typeNode(node, container);
            }
        }
    </script>
</body>

</html>