<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clinova Rx</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        @media print { 
            * { background: transparent !important; box-shadow: none !important; color: black !important; }
            .no-print { display: none !important; } 
            body { background: white !important; font-size: 12pt; margin: 0; }
            .print-area { border: none !important; box-shadow: none !important; padding: 0 !important; }
        }
        #content table { width: 100%; max-width: 100%; table-layout: fixed; }
        #content th, #content td { word-break: break-word; }
    </style>
</head>
<body class="bg-slate-50 min-h-screen p-4 sm:p-6 md:p-8 font-sans text-slate-800 text-base leading-relaxed">

    <!-- LOGIN UI -->
    <div id="loginScreen" class="min-h-screen flex items-center justify-center">
        <div class="w-full max-w-5xl grid md:grid-cols-2 gap-8 md:gap-10 items-center px-1">
            <div class="space-y-4">
                <p class="inline-flex items-center gap-2 text-xs font-semibold text-blue-900 bg-blue-100 px-3 py-1 rounded-full w-fit tracking-tight">Clinova Rx ¬∑ India</p>
                <h1 class="text-4xl md:text-5xl font-extrabold text-blue-900 leading-tight tracking-tight">Dictate faster, prescribe smarter.</h1>
                <p class="text-lg text-slate-700">Voice-first scribing built for Indian doctors. Capture visits in seconds, auto-format Rx, and print instantly.</p>
                <div class="grid grid-cols-2 gap-4 text-sm text-slate-700">
                    <div class="bg-white border border-slate-200 rounded-xl p-4 shadow-lg">
                        <div class="text-2xl font-bold text-blue-900">10x</div>
                        <div class="text-xs uppercase tracking-wide text-slate-500">Faster note taking</div>
                    </div>
                    <div class="bg-white border border-slate-200 rounded-xl p-4 shadow-lg">
                        <div class="text-2xl font-bold text-blue-900">Secure</div>
                        <div class="text-xs uppercase tracking-wide text-slate-500">On-device mic, secured APIs</div>
                    </div>
                </div>
                <ul class="space-y-2 text-sm text-slate-700">
                    <li class="flex items-start gap-2"><span class="mt-2 h-1.5 w-1.5 rounded-full bg-blue-700"></span> Live transcription tuned for EN-IN medical dictation</li>
                    <li class="flex items-start gap-2"><span class="mt-2 h-1.5 w-1.5 rounded-full bg-blue-700"></span> One-tap macros for common protocols and advice</li>
                    <li class="flex items-start gap-2"><span class="mt-2 h-1.5 w-1.5 rounded-full bg-blue-700"></span> Print-ready HTML prescription with your header and NMC ID</li>
                </ul>
            </div>
            <div class="bg-white p-8 rounded-2xl shadow-2xl border border-slate-200">
                <h2 class="text-2xl font-bold text-blue-900 mb-2 tracking-tight">Login to continue</h2>
                <p class="text-sm text-slate-600 mb-4">Access your prescriptions, macros, and settings.</p>
                <input id="loginPhone" placeholder="Phone Number" class="w-full bg-slate-50 border border-slate-300 p-3 rounded-md mb-3 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                <input id="loginPass" type="password" placeholder="Password" class="w-full bg-slate-50 border border-slate-300 p-3 rounded-md mb-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                <p id="loginError" class="text-xs text-rose-600 h-4 mb-2"></p>
                <button onclick="login()" class="w-full bg-blue-800 hover:bg-blue-900 text-white py-3 rounded-lg font-semibold shadow transition-all">Login</button>
                <div class="text-center text-xs text-slate-500 mt-4">
                    New here? <a href="/register" class="text-blue-800 font-semibold hover:underline">Create an account</a>
                </div>
            </div>
        </div>
    </div>

    <!-- MAIN APP -->
    <div id="appScreen" class="hidden min-h-screen flex flex-col items-center gap-4">
        <div class="w-full max-w-3xl no-print px-1 sm:px-0">
            <div class="text-blue-900 font-extrabold text-3xl tracking-tight">Clinova Rx</div>
        </div>
        <div class="w-full max-w-3xl no-print mb-4 px-1 sm:px-0">
            <div class="bg-white border border-slate-200 rounded-lg shadow px-4 py-3 text-sm font-semibold text-slate-800">
                <div class="sm:hidden space-y-2">
                    <div class="flex items-center justify-between gap-3">
                        <button onclick="document.getElementById('macroModal').classList.remove('hidden')" class="text-slate-800 hover:text-blue-700">Voice Macros</button>
                        <div class="flex items-center gap-2">
                            <span class="px-3 py-1 rounded-full bg-slate-100 text-slate-800">Rx: <span id="creditDisplay">0</span></span>
                            <button onclick="logout()" class="text-slate-700 hover:text-blue-700">Logout</button>
                        </div>
                    </div>
                    <div class="flex justify-center">
                        <div id="aiReviewToggleMobile" class="relative flex items-center gap-2 bg-white border border-slate-200 rounded-md px-3 py-2 cursor-pointer hover:shadow-md transition w-full justify-between" onclick="handleAiToggleClick()">
                            <div class="flex flex-col leading-tight">
                                <div class="text-[10px] uppercase tracking-wide text-slate-500">AI Reviewer</div>
                                <div id="aiToggleLabelMobile" class="text-sm font-semibold text-blue-900">Enabled</div>
                            </div>
                            <div class="flex items-center gap-2">
                                <div class="relative group">
                                    <button type="button" class="inline-flex items-center justify-center w-6 h-6 rounded-full bg-blue-50 text-blue-600 text-xs font-bold focus:outline-none">
                                        i
                                    </button>
                                    <div class="absolute left-1/2 -translate-x-1/2 top-full mt-2 w-64 text-xs text-slate-700 bg-white border border-slate-200 rounded-lg shadow-xl px-3 py-2 opacity-0 group-hover:opacity-100 group-focus-within:opacity-100 transition z-40">
                                        Automatically reviews AI output for safety, catches hallucinations, and formats before printing.
                                    </div>
                                </div>
                                <div id="aiToggleTrackMobile" class="w-12 h-6 rounded-full bg-slate-200 transition relative overflow-hidden">
                                    <div id="aiToggleKnobMobile" class="absolute top-0.5 left-0.5 w-5 h-5 rounded-full bg-white shadow transition-transform duration-200"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="hidden sm:grid grid-cols-3 items-center gap-2">
                    <div class="flex items-center justify-start">
                        <button onclick="document.getElementById('macroModal').classList.remove('hidden')" class="text-slate-800 hover:text-blue-700">Voice Macros</button>
                    </div>
                    <div class="flex justify-center">
                        <div id="aiReviewToggle" class="relative flex items-center gap-2 bg-white border border-slate-200 rounded-md px-3 py-2 cursor-pointer hover:shadow-md transition" onclick="handleAiToggleClick()">
                            <div class="flex flex-col leading-tight">
                                <div class="text-[10px] uppercase tracking-wide text-slate-500">AI Reviewer</div>
                                <div id="aiToggleLabel" class="text-sm font-semibold text-blue-900">Enabled</div>
                            </div>
                            <div class="flex items-center gap-2">
                                <div class="relative group">
                                    <button type="button" class="inline-flex items-center justify-center w-6 h-6 rounded-full bg-blue-50 text-blue-600 text-xs font-bold focus:outline-none">
                                        i
                                    </button>
                                    <div class="absolute left-1/2 -translate-x-1/2 top-full mt-2 w-64 text-xs text-slate-700 bg-white border border-slate-200 rounded-lg shadow-xl px-3 py-2 opacity-0 group-hover:opacity-100 group-focus-within:opacity-100 transition z-40">
                                        Automatically reviews AI output for safety, catches hallucinations, and formats before printing.
                                    </div>
                                </div>
                                <div id="aiToggleTrack" class="w-12 h-6 rounded-full bg-slate-200 transition relative overflow-hidden">
                                    <div id="aiToggleKnob" class="absolute top-0.5 left-0.5 w-5 h-5 rounded-full bg-white shadow transition-transform duration-200"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="flex items-center justify-end gap-3">
                        <span class="px-3 py-1 rounded-full bg-slate-100 text-slate-800">Prescriptions: <span id="creditDisplayDesktop">0</span></span>
                        <button onclick="logout()" class="text-slate-700 hover:text-blue-700">Logout</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="max-w-3xl w-full bg-white rounded-2xl shadow-2xl border border-slate-200 overflow-visible print-area min-h-[65vh] sm:min-h-[75vh] md:min-h-[80vh] flex flex-col relative">
            <div class="px-4 sm:px-6 py-3 sm:py-4 flex justify-end items-center border-b border-slate-100 no-print">
                <span id="headerStatus" class="text-xs text-emerald-600 h-4 font-semibold"></span>
            </div>
            <div class="relative">
                <div id="docHeader" contenteditable="true" class="p-4 sm:p-6 md:p-8 cursor-text hover:bg-slate-50 transition font-sans text-slate-800"></div>
                <div id="headerActions" class="hidden absolute top-3 right-3 sm:top-4 sm:right-6 flex items-center gap-2 bg-white/95 border border-slate-200 rounded-md shadow px-2 py-1 no-print">
                    <button onclick="saveHeader()" class="w-8 h-8 flex items-center justify-center rounded-md bg-emerald-500 text-white hover:bg-emerald-600 transition" aria-label="Save header">
                        <svg class="w-4 h-4" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M4 10.5 8.5 15 16 6"/>
                        </svg>
                    </button>
                    <button onclick="discardHeaderChanges()" class="w-8 h-8 flex items-center justify-center rounded-md bg-rose-500 text-white hover:bg-rose-600 transition" aria-label="Discard header changes">
                        <svg class="w-4 h-4" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M5 5 15 15M15 5 5 15"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div id="livePreview" class="px-4 sm:px-8 pt-2 text-slate-400 text-sm italic h-6 overflow-hidden"></div>
            <div id="content" contenteditable="true" class="p-4 sm:p-6 md:p-8 flex-grow prose max-w-none focus:outline-none font-sans text-slate-800 overflow-x-auto">
                <p id="placeholder" class="text-slate-300 italic no-print">Tap to start prescription...</p>
            </div>
            <div class="bg-white px-4 sm:px-6 md:px-8 py-4 sm:py-5 border-t border-slate-100 no-print">
                <div class="w-full max-w-3xl mx-auto flex flex-col items-center gap-3">
                    <div id="countdownBadge" class="hidden text-xs font-semibold text-amber-600 bg-amber-100 px-2 py-1 rounded-full text-center"></div>
                    <div class="w-full">
                        <canvas id="waveform" class="w-full h-10 rounded-full bg-slate-100 border border-slate-200 opacity-0 transition-opacity duration-500"></canvas>
                    </div>
                    <div class="relative flex flex-col items-center gap-1">
                        <div class="flex items-center gap-4">
                            <button id="recordFab" onclick="handleRecordAction()" class="w-16 h-16 sm:w-20 sm:h-20 rounded-full bg-rose-600 text-white shadow-xl border-4 border-white flex items-center justify-center transition-all active:scale-95">
                                <svg id="recordIcon" class="w-7 h-7" fill="currentColor" viewBox="0 0 24 24">
                                    <path d="M12 14a3 3 0 0 0 3-3V7a3 3 0 1 0-6 0v4a3 3 0 0 0 3 3Z"/><path d="M7 11a5 5 0 0 0 10 0h-1.5a3.5 3.5 0 0 1-7 0H7Z"/><path d="M12 17v3m0 0h-3m3 0h3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                                </svg>
                            </button>
                            <button id="stopButton" onclick="handleStopAction()" class="hidden w-16 h-16 sm:w-20 sm:h-20 rounded-full bg-slate-800 text-white shadow-xl border-4 border-white flex items-center justify-center transition-all active:scale-95">
                                <svg id="stopIcon" class="w-6 h-6" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>
                                <span class="sr-only">Stop</span>
                            </button>
                        </div>
                    </div>
                    <p id="recordLabel" class="text-sm font-semibold text-slate-700">Tap to start prescription</p>
                    <p id="status" class="text-center text-xs text-slate-500 font-bold min-h-[1.5rem] whitespace-pre-line px-4">READY</p>
                </div>
                <div class="w-full flex flex-col md:grid md:grid-cols-3 items-center mt-4 gap-3">
                    <div class="flex justify-center w-full order-1 md:order-2">
                        <div class="text-blue-900 font-mono text-lg tracking-wide" id="timerDisplay">00:00</div>
                    </div>
                    <div class="flex justify-center md:justify-end items-center gap-3 w-full order-2 md:order-3 md:pr-2 lg:pr-4">
                        <button onclick="handleClear()" class="px-4 py-2 text-slate-700 hover:bg-slate-100 rounded-lg text-xs font-semibold">Clear</button>
                        <button onclick="handleCopy()" class="bg-white border border-slate-200 hover:border-blue-300 text-slate-800 px-4 py-2 rounded-lg text-sm font-semibold shadow-sm transition inline-flex items-center gap-2">
                            <svg class="w-4 h-4" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M6 6.75A1.75 1.75 0 0 1 7.75 5h5.5A1.75 1.75 0 0 1 15 6.75v8.5A1.75 1.75 0 0 1 13.25 17h-5.5A1.75 1.75 0 0 1 6 15.25z"/><path d="M12 3H6.75A1.75 1.75 0 0 0 5 4.75v9.5"/></svg>
                            Copy
                        </button>
                        <button onclick="handlePrint()" class="bg-blue-800 hover:bg-blue-900 text-white px-5 py-2 rounded-lg text-sm font-semibold shadow transition inline-flex items-center gap-2">
                            <svg class="w-4 h-4" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M6 8V4.5A1.5 1.5 0 0 1 7.5 3h5A1.5 1.5 0 0 1 14 4.5V8"/><rect x="5" y="9" width="10" height="6.5" rx="1"/><path d="M7 13.5h6"/></svg>
                            Print
                        </button>
                    </div>
                    <div class="flex justify-center md:justify-start items-center gap-3 w-full order-3 md:order-1 md:pl-2 lg:pl-4">
                        <div class="relative">
                            <button id="fontButton" onclick="toggleFontMenu()" class="bg-white border border-slate-200 rounded-md px-3 py-2 text-xs font-medium text-slate-700 shadow-sm flex items-center gap-1 focus:outline-none focus:ring-2 focus:ring-blue-500 hover:border-blue-300">
                                <svg class="w-4 h-4 text-slate-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.89 3.31.877 2.42 2.42a1.724 1.724 0 001.065 2.572c1.757.426 1.757 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.89 1.543-.877 3.31-2.42 2.42a1.724 1.724 0 00-2.572 1.065c-.427 1.757-2.925 1.757-3.351 0a1.724 1.724 0 00-2.572-1.066c-1.543.89-3.31-.876-2.42-2.42a1.724 1.724 0 00-1.065-2.572c-1.757-.427-1.757-2.925 0-3.351a1.724 1.724 0 001.066-2.572c-.89-1.543.877-3.31 2.42-2.42.996.574 2.273.096 2.572-1.065z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8" d="M12 15.75a3.75 3.75 0 100-7.5 3.75 3.75 0 000 7.5z"/></svg>
                            </button>
                            <div id="fontMenu" class="hidden absolute left-0 bottom-full mb-1 w-56 bg-white border border-slate-200 rounded-md shadow-lg text-xs font-medium text-slate-800 z-50 p-3 space-y-3">
                                <div>
                                    <label class="block text-[11px] text-slate-600 mb-1">Font family</label>
                                    <select id="fontFamilySelect" class="w-full bg-slate-50 border border-slate-200 rounded-md px-2 py-1 text-xs text-slate-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
                                        <option value="'Inter', sans-serif">Sans (Inter)</option>
                                        <option value="Georgia, serif">Serif (Georgia)</option>
                                        <option value="'Source Sans Pro', sans-serif">Sans (Source Sans)</option>
                                        <option value="'Roboto Mono', monospace">Mono (Roboto Mono)</option>
                                    </select>
                                </div>
                                <div>
                                    <label class="block text-[11px] text-slate-600 mb-1">Font size</label>
                                    <select id="fontSizeSelect" class="w-full bg-slate-50 border border-slate-200 rounded-md px-2 py-1 text-xs text-slate-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
                                        <option value="14px" selected>14 px</option>
                                        <option value="16px">16 px</option>
                                        <option value="18px">18 px</option>
                                        <option value="20px">20 px</option>
                                    </select>
                                </div>
                                <div class="flex justify-end">
                                    <button class="text-blue-800 text-xs font-semibold" onclick="applyFontSettings()">Apply</button>
                                </div>
                            </div>
                        </div>
                        <div class="relative">
                        <button id="modeButton" onclick="toggleModeMenu()" class="bg-white border border-slate-200 rounded-md px-3 py-2 text-xs font-medium text-slate-700 shadow-sm flex items-center gap-2 focus:outline-none focus:ring-2 focus:ring-blue-500 hover:border-blue-300">
                            <span id="modeLabel" class="flex items-center gap-1 whitespace-nowrap">üîç Offline (High Accuracy)</span>
                                <span class="text-slate-500 text-xs">‚åÑ</span>
                            </button>
                            <div id="modeMenu" class="hidden absolute right-0 bottom-full mb-1 w-56 bg-white border border-slate-200 rounded-md shadow-lg text-xs font-medium text-slate-800 z-50">
                                <div class="flex items-center justify-between px-3 py-2 cursor-pointer hover:bg-slate-50" onclick="selectMode('live')">
                                    <span class="flex items-center gap-2 whitespace-nowrap">‚ö° Live (Faster)</span>
                                    <span id="checkLive" class="text-blue-600 text-xs">‚úì</span>
                                </div>
                                <div class="border-t border-slate-200"></div>
                                <div class="flex items-center justify-between px-3 py-2 cursor-pointer hover:bg-slate-50" onclick="selectMode('offline')">
                                    <span class="flex items-center gap-2 whitespace-nowrap">üîç Offline (High Accuracy)</span>
                                    <span id="checkOffline" class="text-blue-600 text-xs hidden">‚úì</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- SETTINGS & MACRO MODALS (Standard) -->
    <div id="settingsModal" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-50 no-print">
        <div class="bg-white rounded-2xl p-6 w-full max-w-lg shadow-2xl border border-slate-200">
            <h2 class="font-bold text-blue-900 mb-4 tracking-tight">Settings</h2>
            <input id="in_name" placeholder="Name" class="w-full bg-slate-50 border border-slate-300 p-3 mb-2 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            <input id="in_qual" placeholder="Qualifications" class="w-full bg-slate-50 border border-slate-300 p-3 mb-2 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            <input id="in_reg" placeholder="Reg No" class="w-full bg-slate-50 border border-slate-300 p-3 mb-2 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            <textarea id="in_clinic" placeholder="Clinic Address" class="w-full bg-slate-50 border border-slate-300 p-3 mb-2 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"></textarea>
            <input id="in_keywords" placeholder="Keywords (Brand names)" class="w-full bg-slate-50 border border-slate-300 p-3 mb-2 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            <div class="flex justify-end gap-3 mt-4">
                <button onclick="document.getElementById('settingsModal').classList.add('hidden')" class="px-4 py-2 text-slate-600 hover:bg-slate-100 rounded-lg">Cancel</button>
                <button onclick="saveSettings()" class="bg-blue-800 hover:bg-blue-900 text-white px-5 py-2 rounded-lg font-semibold shadow transition">Save</button>
            </div>
        </div>
    </div>

    <div id="macroModal" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-50 no-print">
        <div class="bg-white rounded-2xl p-6 w-full max-w-2xl shadow-2xl border border-slate-200">
            <h2 class="font-bold text-blue-900 mb-1 tracking-tight">Macros</h2>
            <p class="text-xs text-slate-600 mb-3">Speak the trigger phrase during dictation to insert the macro (e.g., ‚Äúapply fever protocol‚Äù).</p>
            <input id="macroTrigger" placeholder="Trigger" class="w-full bg-slate-50 border border-slate-300 p-3 mb-2 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            <textarea id="macroExpansion" placeholder="Expansion..." class="w-full bg-slate-50 border border-slate-300 p-3 mb-2 rounded-md h-40 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"></textarea>
            <div class="flex justify-end gap-3">
                <button onclick="document.getElementById('macroModal').classList.add('hidden')" class="px-4 py-2 text-slate-600 hover:bg-slate-100 rounded-lg">Close</button>
                <button onclick="saveMacro()" class="bg-blue-800 hover:bg-blue-900 text-white px-5 py-2 rounded-lg font-semibold shadow transition">Save</button>
            </div>
            <div id="macroList" class="mt-4 pt-4 border-t border-slate-200 text-xs h-48 overflow-y-auto"></div>
        </div>
    </div>

    <div id="consentModal" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-50 no-print">
        <div class="bg-white rounded-2xl shadow-2xl w-full max-w-md p-6 border border-slate-200">
            <h2 class="text-lg font-bold text-blue-900 mb-2 tracking-tight">Confirm &amp; Proceed</h2>
            <p class="text-sm text-slate-700 mb-4">I understand the prescriptions are generated by Clinova Rx and I accept full responsibility for clinical decisions and patient risk.</p>
            <div class="flex justify-end gap-3">
                <button onclick="closeConsent()" class="px-4 py-2 text-slate-600 hover:bg-slate-100 rounded-lg">Cancel</button>
                <button onclick="confirmConsent()" class="px-4 py-2 bg-blue-800 hover:bg-blue-900 text-white rounded-lg font-semibold shadow">Agree &amp; Continue</button>
            </div>
        </div>
    </div>

    <script>
        const getApiBase = () => {
            if (window.location.protocol === 'blob:' || window.location.origin === 'null') {
                return 'http://localhost:3000';
            }
            const host = window.location.hostname;
            if (host === 'localhost' || host === '127.0.0.1') {
                return window.location.port === '3000' ? '' : 'http://localhost:3000';
            }
            return '';
        };
        const API_BASE = getApiBase();
        const socket = API_BASE ? io(API_BASE) : io();
        
        let mediaRecorder, isRecording = false, transcriptBuffer = "", timerInterval;
        let backupAudioChunks = [];
        let recordedMimeType = ''; // To store the browser's native mime type
        let audioCtx, sourceNode, processorNode, analyserNode, waveformAnim;
        let pcmQueue = [];
        let recordState = 'idle'; // idle | recording | paused | processing
        let elapsedSeconds = 0;
        const MIN_RECORD_SECONDS = 5; // discard shorter clips
        let transcriptionMode = 'offline'; // 'live' or 'offline'
        let modeLocked = false;
        let fontMenuOpen = false;
        let reviewEnabled = false;
        let pendingHtml = "";
        let savedHeaderHtml = "";
        let headerDirty = false;
        let headerStatusTimeout;
        let currentFontFamily = "'Inter', sans-serif";
        let currentFontSize = "14px";
        let consentAction = 'print';

        // --- AUTH ---
        window.onload = initApp;
        async function login() {
            const phone = document.getElementById('loginPhone').value;
            const pass = document.getElementById('loginPass').value;
            const res = await fetch('/api/login', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ phone, password: pass }) });
            const data = await res.json();
            if (data.success) {
                document.getElementById('loginError').innerText = "";
                window.location.href = '/dashboard';
            } else {
                document.getElementById('loginError').innerText = "Login failed. Check phone/password.";
            }
        }

        async function autoReview() {
            const html = pendingHtml || document.getElementById('content').innerHTML;
            if (!html || html.trim() === "") {
                updateStatus("No prescription to review", "text-amber-600");
                setRecordState('idle');
                modeLocked = false;
                return;
            }
            updateStatus("AI review in progress‚Ä¶", "text-blue-600");
            try {
                const res = await fetch('/api/review', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ html })
                });
                const data = await res.json();
                if (data.success) {
                    pendingHtml = data.reviewed;
                    updateStatus("Formatting...", "text-blue-600");
                    await autoFormat();
                } else {
                    updateStatus("Review failed", "text-red-500");
                    setRecordState('idle');
                    modeLocked = false;
                }
            } catch (e) {
                updateStatus("Review failed", "text-red-500");
                setRecordState('idle');
                modeLocked = false;
            } 
        }
        async function logout() { 
            await fetch('/api/logout', { method: 'POST' });
            window.location.href = '/';
        }
       async function initApp() {
            // load client preferences before showing UI
            const savedReview = localStorage.getItem('aiReviewEnabled');
            if (savedReview !== null) {
                setReviewEnabled(savedReview === 'true', true);
            }
            const savedMode = localStorage.getItem('transcriptionMode');
            if (savedMode === 'live' || savedMode === 'offline') {
                setMode(savedMode, true);
            }
            setMode(transcriptionMode, true);
            try {
                const res = await fetch('/api/me');
                if (res.status === 401) throw new Error("Unauthorized");
                const data = await res.json();
                setCreditDisplay(data.credits);
                const headerEl = document.getElementById('docHeader');
                if (headerEl) {
                    headerEl.innerHTML = data.header_html || "<h1>Dr. Name</h1><p>Edit Header...</p>";
                    setHeaderBaseline(headerEl.innerHTML);
                    applyCurrentFontToHeader();
                }
                document.getElementById('loginScreen').classList.add('hidden');
                document.getElementById('appScreen').classList.remove('hidden');
                loadMacros();
            } catch (e) {}
        }
        async function autoFormat() {
            const html = pendingHtml || document.getElementById('content').innerHTML;
            if (!html || html.trim() === "") {
                updateStatus("No prescription to format", "text-amber-600");
                setRecordState('idle');
                modeLocked = false;
                return;
            }
            try {
                const res = await fetch('/api/format', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ html })
                });
                const data = await res.json();
                if (data.success) {
                    document.getElementById('content').innerHTML = data.formatted;
                    pendingHtml = "";
                    updateStatus("DONE", "text-green-600");
                } else {
                    updateStatus("Formatting failed", "text-red-500");
                }
            } catch (e) {
                updateStatus("Formatting failed", "text-red-500");
            } finally {
                setRecordState('done');
                modeLocked = false;
                setTimeout(() => setRecordState('idle'), 1200);
            }
        }
        function setHeaderStatus(text, colorClass = "text-emerald-600") {
            const statusEl = document.getElementById('headerStatus');
            if (!statusEl) return;
            statusEl.innerText = text;
            statusEl.className = `text-xs font-semibold h-4 ${colorClass}`;
            if (headerStatusTimeout) clearTimeout(headerStatusTimeout);
            if (text) headerStatusTimeout = setTimeout(() => { statusEl.innerText = ""; }, 2000);
        }

        function toggleHeaderActions(show) {
            const actions = document.getElementById('headerActions');
            if (!actions) return;
            actions.classList.toggle('hidden', !show);
        }

        function setHeaderBaseline(html) {
            savedHeaderHtml = html || "";
            headerDirty = false;
            toggleHeaderActions(false);
        }

        function markHeaderDirty() {
            const el = document.getElementById('docHeader');
            if (!el) return;
            const isDirty = el.innerHTML.trim() !== (savedHeaderHtml || "").trim();
            headerDirty = isDirty;
            toggleHeaderActions(isDirty);
        }

        function discardHeaderChanges() {
            const el = document.getElementById('docHeader');
            if (!el) return;
            el.innerHTML = savedHeaderHtml || "";
            headerDirty = false;
            toggleHeaderActions(false);
            setHeaderStatus("Changes discarded", "text-slate-500");
        }

        async function saveHeader() {
            const docHeaderEl = document.getElementById('docHeader');
            if (!docHeaderEl) return;
            const html = docHeaderEl.innerHTML;
            try {
                const res = await fetch('/api/header', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ html }) });
                if (!res.ok) throw new Error("Save failed");
                setHeaderStatus("Header saved", "text-emerald-600");
                setHeaderBaseline(html);
            } catch (e) {
                setHeaderStatus("Save failed", "text-rose-600");
            }
        }

        // --- SOCKET EVENTS ---
        socket.on('transcript-update', (data) => {
            if (data.isFinal) {
                transcriptBuffer += " " + data.text;
                document.getElementById('livePreview').innerText = "";
                updateStatus("CAPTURED", "text-blue-600");
            } else {
                document.getElementById('livePreview').innerText = data.text;
                updateStatus("HEARING...", "text-red-500");
            }
        });

        socket.on('prescription-result', (data) => {
            handleResult(data);
        });

        socket.on('use-backup-upload', () => {
            document.getElementById('status').innerText = "USING BACKUP...";
            document.getElementById('status').className = "text-center text-xs text-yellow-600 font-bold mb-4";
            uploadBackup();
        });

        function updateStatus(text, colorClass) {
            const statusEl = document.getElementById('status');
            statusEl.innerText = text;
            statusEl.className = `text-center text-xs font-bold mb-4 min-h-[1.5rem] whitespace-pre-line px-4 ${colorClass || 'text-gray-500'}`;
        }

        function setTimerDisplayText(text) {
            const desktop = document.getElementById('timerDisplay');
            if (desktop) desktop.innerText = text;
        }

        function setCreditDisplay(value) {
            const primary = document.getElementById('creditDisplay');
            const secondary = document.getElementById('creditDisplayDesktop');
            if (primary) primary.innerText = value;
            if (secondary) secondary.innerText = value;
        }

        function setMode(mode, skipPersist = false) {
            transcriptionMode = mode;
            const label = document.getElementById('modeLabel');
            const checkLive = document.getElementById('checkLive');
            const checkOffline = document.getElementById('checkOffline');
            if (mode === 'live') {
                updateStatus("READY (Live)", "text-gray-500");
                label.innerText = "‚ö° Live (Faster)";
                checkLive.classList.remove('hidden');
                checkOffline.classList.add('hidden');
            } else {
                updateStatus("READY (Offline high accuracy)", "text-gray-500");
                label.innerText = "üîç Offline (High Accuracy)";
                checkOffline.classList.remove('hidden');
                checkLive.classList.add('hidden');
            }
            closeModeMenu();
            if (!skipPersist) localStorage.setItem('transcriptionMode', transcriptionMode);
        }

        function toggleModeMenu() {
            if (modeLocked) return;
            const menu = document.getElementById('modeMenu');
            menu.classList.toggle('hidden');
        }

        function closeModeMenu() {
            const menu = document.getElementById('modeMenu');
            if (menu) menu.classList.add('hidden');
        }

        function selectMode(mode) {
            if (modeLocked) return;
            setMode(mode);
        }

        function toggleFontMenu() {
            const menu = document.getElementById('fontMenu');
            fontMenuOpen = !fontMenuOpen;
            if (fontMenuOpen) {
                syncFontControls();
                menu.classList.remove('hidden');
            } else {
                menu.classList.add('hidden');
            }
        }

        function closeFontMenu() {
            const menu = document.getElementById('fontMenu');
            if (menu) {
                menu.classList.add('hidden');
                fontMenuOpen = false;
            }
        }

        const normalizeFont = (val) => (val || "").toLowerCase().replace(/["']/g, '').replace(/\s+/g, '');

        function syncFontControls() {
            const content = document.getElementById('content');
            if (!content) return;
            const style = window.getComputedStyle(content);
            currentFontFamily = style.fontFamily;
            currentFontSize = style.fontSize;
            const familySelect = document.getElementById('fontFamilySelect');
            const sizeSelect = document.getElementById('fontSizeSelect');
            if (familySelect) {
                const normalizedFamily = normalizeFont(currentFontFamily);
                const match = Array.from(familySelect.options).find(opt => normalizeFont(opt.value) === normalizedFamily);
                familySelect.value = match ? match.value : familySelect.options[0].value;
            }
            if (sizeSelect) {
                const matchSize = Array.from(sizeSelect.options).find(opt => opt.value === currentFontSize);
                sizeSelect.value = matchSize ? matchSize.value : sizeSelect.options[0].value;
            }
            applyCurrentFontToHeader(style);
        }

        function applyFontSettings() {
            const family = document.getElementById('fontFamilySelect').value;
            const size = document.getElementById('fontSizeSelect').value;
            currentFontFamily = family;
            currentFontSize = size;
            document.getElementById('content').style.fontFamily = family;
            document.getElementById('content').style.fontSize = size;
            document.getElementById('docHeader').style.fontFamily = family;
            document.getElementById('docHeader').style.fontSize = size;
            closeFontMenu();
        }

        function applySelectedFontDefaults() {
            const familySelect = document.getElementById('fontFamilySelect');
            const sizeSelect = document.getElementById('fontSizeSelect');
            if (!familySelect || !sizeSelect) return;
            currentFontFamily = familySelect.value;
            currentFontSize = sizeSelect.value;
            const content = document.getElementById('content');
            const header = document.getElementById('docHeader');
            if (content) {
                content.style.fontFamily = currentFontFamily;
                content.style.fontSize = currentFontSize;
            }
            if (header) {
                header.style.fontFamily = currentFontFamily;
                header.style.fontSize = currentFontSize;
            }
        }

        function applyCurrentFontToHeader(styleObj) {
            const content = document.getElementById('content');
            const header = document.getElementById('docHeader');
            if (!content || !header) return;
            const style = styleObj || window.getComputedStyle(content);
            header.style.fontFamily = style.fontFamily;
            header.style.fontSize = style.fontSize;
            header.style.lineHeight = style.lineHeight;
        }

        function setReviewEnabled(value, skipPersist = false) {
            reviewEnabled = value;
            const toggle = document.getElementById('reviewToggle');
            if (toggle) toggle.checked = reviewEnabled;

            const knobs = [document.getElementById('aiToggleKnob'), document.getElementById('aiToggleKnobMobile')].filter(Boolean);
            const labels = [document.getElementById('aiToggleLabel'), document.getElementById('aiToggleLabelMobile')].filter(Boolean);
            const wraps = [document.getElementById('aiReviewToggle'), document.getElementById('aiReviewToggleMobile')].filter(Boolean);
            const tracks = [document.getElementById('aiToggleTrack'), document.getElementById('aiToggleTrackMobile')].filter(Boolean);

            knobs.forEach(knob => {
                knob.style.transform = reviewEnabled ? 'translateX(24px)' : 'translateX(0px)';
                knob.className = `absolute top-0.5 left-0.5 w-5 h-5 rounded-full bg-white shadow transition-transform duration-200`;
            });
            labels.forEach(label => {
                label.innerText = reviewEnabled ? "Enabled" : "Disabled";
                label.className = `text-sm font-semibold ${reviewEnabled ? 'text-blue-900' : 'text-slate-500'}`;
            });
            wraps.forEach(wrap => {
                wrap.classList.toggle('ring-2', reviewEnabled);
                wrap.classList.toggle('ring-green-200', reviewEnabled);
                wrap.classList.toggle('bg-green-50', reviewEnabled);
            });
            tracks.forEach(track => {
                track.className = `w-12 h-6 rounded-full transition relative overflow-hidden ${reviewEnabled ? 'bg-green-500' : 'bg-slate-200'}`;
            });
            if (!skipPersist) localStorage.setItem('aiReviewEnabled', reviewEnabled ? 'true' : 'false');
        }

        function toggleReviewSetting() {
            if (isRecording || recordState === 'processing') {
                const toggle = document.getElementById('reviewToggle');
                if (toggle) toggle.checked = reviewEnabled;
                return;
            }
            setReviewEnabled(!reviewEnabled);
        }

        function handleAiToggleClick() {
            if (isRecording || recordState === 'processing') return;
            setReviewEnabled(!reviewEnabled);
        }

        const setFabIcon = (mode) => {
            const icon = document.getElementById('recordIcon');
            if (!icon) return;
            icon.setAttribute('viewBox', '0 0 24 24');
            const baseClass = "w-7 h-7";
            const icons = {
                mic: `<path d="M12 14a3 3 0 0 0 3-3V7a3 3 0 1 0-6 0v4a3 3 0 0 0 3 3Z"/><path d="M7 11a5 5 0 0 0 10 0h-1.5a3.5 3.5 0 0 1-7 0H7Z"/><path d="M12 17v3m0 0h-3m3 0h3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>`,
                pause: `<path d="M7 5h4v14H7zM13 5h4v14h-4z"/>`,
                play: `<path d="M8 5v14l11-7z"/>`,
                check: `<path d="M9 12l2 2 4-4" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>`,
            };
            icon.className = baseClass;
            if (mode === 'spinner') {
                icon.className = "w-7 h-7 text-white animate-pulse";
                icon.innerHTML = `<svg class="w-7 h-7" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M7 2h10a1 1 0 0 1 1 1v1.2a3 3 0 0 1-.88 2.12L14 9l3.12 2.68A3 3 0 0 1 18 13.8V15a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1v-1.2a3 3 0 0 1 .88-2.12L10 9 6.88 6.32A3 3 0 0 1 6 4.2V3a1 1 0 0 1 1-1Z"/>
                    <path d="M10 3h4" />
                    <path d="M10 21h4" />
                </svg>`;
            } else if (mode === 'mic') {
                icon.innerHTML = icons.mic;
            } else if (mode === 'pause') {
                icon.innerHTML = icons.pause;
            } else if (mode === 'play') {
                icon.innerHTML = icons.play;
            } else if (mode === 'check') {
                icon.innerHTML = icons.check;
            } else {
                icon.innerHTML = icons.mic;
            }
        };

        function setRecordState(state) {
            recordState = state;
            const fab = document.getElementById('recordFab');
            const label = document.getElementById('recordLabel');
            const wave = document.getElementById('waveform');
            const stopBtn = document.getElementById('stopButton');

            if (state === 'idle') {
                fab.className = "w-16 h-16 rounded-full bg-red-600 text-white shadow-lg flex items-center justify-center transition-all active:scale-95";
                setFabIcon('mic');
                label.innerText = "Tap to start prescription";
                wave.classList.add('opacity-0');
                if (stopBtn) stopBtn.classList.add('hidden');
                setTimerDisplayText("00:00");
            } else if (state === 'recording') {
                fab.className = "w-16 h-16 rounded-full bg-red-600 text-white shadow-lg flex items-center justify-center transition-all scale-105 animate-pulse";
                setFabIcon('pause');
                label.innerText = "Recording... Tap to pause";
                wave.classList.remove('opacity-0');
                if (stopBtn) stopBtn.classList.remove('hidden');
            } else if (state === 'paused') {
                fab.className = "w-16 h-16 rounded-full bg-amber-500 text-white shadow-lg flex items-center justify-center transition-all";
                setFabIcon('play');
                label.innerText = "Paused. Tap to resume";
                wave.classList.add('opacity-0');
                if (stopBtn) stopBtn.classList.remove('hidden');
            } else if (state === 'processing') {
                fab.className = "w-16 h-16 rounded-full bg-blue-600 text-white shadow-lg flex items-center justify-center transition-all animate-pulse";
                setFabIcon('spinner');
                label.innerText = "Processing...";
                wave.classList.add('opacity-0');
                if (stopBtn) stopBtn.classList.add('hidden');
            } else if (state === 'done') {
                fab.className = "w-16 h-16 rounded-full bg-green-600 text-white shadow-lg flex items-center justify-center transition-all";
                setFabIcon('check');
                label.innerText = "Done";
                wave.classList.add('opacity-0');
                if (stopBtn) stopBtn.classList.add('hidden');
            }
        }

        function startWaveform() {
            const canvas = document.getElementById('waveform');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            if (!analyserNode) return;
            const drawLive = () => {
                analyserNode.getByteTimeDomainData(dataArray);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "rgba(23,105,170,0.08)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = "#1769AA";
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                const sliceWidth = canvas.width / dataArray.length;
                let x = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = (v * canvas.height) / 2;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                    x += sliceWidth;
                }
                ctx.stroke();
                waveformAnim = requestAnimationFrame(drawLive);
            };
            if (waveformAnim) cancelAnimationFrame(waveformAnim);
            analyserNode.fftSize = 128;
            var dataArray = new Uint8Array(analyserNode.frequencyBinCount);
            waveformAnim = requestAnimationFrame(drawLive);
            canvas.classList.remove('opacity-0');
        }

        function stopWaveform() {
            if (waveformAnim) cancelAnimationFrame(waveformAnim);
            waveformAnim = null;
            const canvas = document.getElementById('waveform');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            canvas.classList.add('opacity-0');
        }

        function flushPcmQueue() {
            if (!pcmQueue.length) return;
            const totalSamples = pcmQueue.reduce((sum, chunk) => sum + chunk.length, 0);
            const merged = new Int16Array(totalSamples);
            let offset = 0;
            pcmQueue.forEach(chunk => { merged.set(chunk, offset); offset += chunk.length; });
            pcmQueue = [];
            socket.emit('audio-stream', { type: 'pcm', data: merged.buffer });
        }

        function handleResult(data) {
            if (timerInterval) clearInterval(timerInterval);
            elapsedSeconds = 0;
            setTimerDisplayText("00:00");
            document.getElementById('countdownBadge').classList.add('hidden');
            stopWaveform();
            if (data.success) {
                setCreditDisplay(data.credits);
                if (reviewEnabled) {
                    pendingHtml = data.html;
                    updateStatus("AI review in progress‚Ä¶", "text-blue-600");
                    autoReview();
                } else {
                    document.getElementById('content').innerHTML = data.html;
                    updateStatus("DONE", "text-green-600");
                    setRecordState('done');
                    modeLocked = false;
                    setTimeout(() => setRecordState('idle'), 1200);
                }
            } else {
                alert(data.error);
                updateStatus("ERROR", "text-red-500");
                setRecordState('idle');
                modeLocked = false;
            }
        }

        // --- RECORDING (Native Streaming) ---
        async function startRecording() {
            if (isRecording || recordState === 'processing') return;
            transcriptBuffer = "";
            backupAudioChunks = [];
            elapsedSeconds = 0;
            setTimerDisplayText("00:00");
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } 
                });

                if (transcriptionMode === 'live') {
                    // Live stream via AudioContext (16k PCM)
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                    sourceNode = audioCtx.createMediaStreamSource(stream);
                    analyserNode = audioCtx.createAnalyser();
                    analyserNode.fftSize = 512;
                    processorNode = audioCtx.createScriptProcessor(4096, 1, 1);
                    sourceNode.connect(analyserNode);
                    analyserNode.connect(processorNode);
                    processorNode.connect(audioCtx.destination);

                    processorNode.onaudioprocess = (e) => {
                        if (!isRecording) return;
                        const input = e.inputBuffer.getChannelData(0);
                        const pcm16 = new Int16Array(input.length);
                        for (let i = 0; i < input.length; i++) {
                            let s = Math.max(-1, Math.min(1, input[i]));
                            pcm16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                        }
                        pcmQueue.push(pcm16);
                        const totalSamples = pcmQueue.reduce((sum, chunk) => sum + chunk.length, 0);
                        if (totalSamples >= 12000) { // ~0.75s
                            const merged = new Int16Array(totalSamples);
                            let offset = 0;
                            pcmQueue.forEach(chunk => { merged.set(chunk, offset); offset += chunk.length; });
                            pcmQueue = [];
                            socket.emit('audio-stream', { type: 'pcm', data: merged.buffer });
                        }
                    };
                } else {
                    // Offline: still create analyser for waveform visualization
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    sourceNode = audioCtx.createMediaStreamSource(stream);
                    analyserNode = audioCtx.createAnalyser();
                    analyserNode.fftSize = 512;
                    sourceNode.connect(analyserNode);
                }

                // Always capture backup/primary recording for final upload
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });
                recordedMimeType = mediaRecorder.mimeType; 
                mediaRecorder.ondataavailable = async (e) => {
                    if (e.data.size > 0) backupAudioChunks.push(e.data);
                };
                mediaRecorder.start(1500);

                isRecording = true;
                setRecordState('recording');
                updateStatus(transcriptionMode === 'live' ? "LISTENING..." : "RECORDING (offline high accuracy)", "text-red-500");
                modeLocked = true;
                startTimer(true);
                startWaveform();

            } catch (e) { 
                updateStatus("Mic permission denied", "text-red-500");
                setRecordState('idle');
                modeLocked = false;
            }
        }

        function pauseRecording() {
            if (recordState !== 'recording') return;
            isRecording = false;
            clearInterval(timerInterval);
            try { if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.pause(); } catch (_) {}
            try { if (audioCtx) audioCtx.suspend(); } catch (_) {}
            setRecordState('paused');
            stopWaveform();
            updateStatus("Paused", "text-amber-600");
        }

        function resumeRecording() {
            if (recordState !== 'paused') return;
            isRecording = true;
            try { if (mediaRecorder && mediaRecorder.state === 'paused') mediaRecorder.resume(); } catch (_) {}
            try { if (audioCtx) audioCtx.resume(); } catch (_) {}
            setRecordState('recording');
            startTimer(false);
            startWaveform();
            updateStatus(transcriptionMode === 'live' ? "LISTENING..." : "RECORDING (offline high accuracy)", "text-red-500");
        }

        function handleRecordAction() {
            if (recordState === 'idle' || recordState === 'done') startRecording();
            else if (recordState === 'recording') pauseRecording();
            else if (recordState === 'paused') resumeRecording();
        }

        function handleStopAction() {
            stopRecording();
        }

        function stopRecording() {
            if (recordState === 'idle' || recordState === 'processing') return;
            isRecording = false;
            clearInterval(timerInterval);
            setRecordState('processing');
            document.getElementById('countdownBadge').classList.add('hidden');

            if (transcriptionMode === 'live') {
                flushPcmQueue();
                if (processorNode) { processorNode.disconnect(); processorNode.onaudioprocess = null; processorNode = null; }
                pcmQueue = [];
            }

            if (sourceNode) { try { sourceNode.disconnect(); } catch (_) {} sourceNode = null; }
            if (analyserNode) { analyserNode = null; }
            if (audioCtx) { try { audioCtx.close(); } catch (_) {} audioCtx = null; }
            stopWaveform();

            if (mediaRecorder) {
                try { mediaRecorder.stop(); } catch (_) {}
            }
            if(mediaRecorder && mediaRecorder.stream) mediaRecorder.stream.getTracks().forEach(t => t.stop());

            const recordedSeconds = elapsedSeconds;
            if (recordedSeconds < MIN_RECORD_SECONDS) { 
                updateStatus("Discarded (<5s)", "text-gray-500");
                setRecordState('idle');
                modeLocked = false;
                backupAudioChunks = [];
                transcriptBuffer = "";
                return;
            }

            if (transcriptionMode === 'live') {
                updateStatus("FORMATTING...", "text-blue-600");
                const cleanContext = document.getElementById('placeholder') ? "" : document.getElementById('content').innerHTML;
                const pendingPreview = document.getElementById('livePreview').innerText;
                const fullText = (transcriptBuffer + " " + pendingPreview).trim();

                setTimeout(() => {
                    socket.emit('finalize-prescription', { fullTranscript: fullText, context: cleanContext });
                }, 2500);
            } else {
                updateStatus("Processing (offline high accuracy)...", "text-blue-600");
                uploadBackup();
            }
        }

        // --- BACKUP UPLOAD ---
        async function uploadBackup() {
            const blob = new Blob(backupAudioChunks, { type: recordedMimeType });
            try {
                // 1. Get presigned URL
                const upRes = await fetch('/api/upload-url', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contentType: recordedMimeType || 'audio/webm' })
                });
                if (!upRes.ok) throw new Error(`Upload URL failed: ${upRes.status}`);
                const upData = await upRes.json();

                // 2. Upload to S3
                const putRes = await fetch(upData.url, {
                    method: 'PUT',
                    headers: { 'Content-Type': recordedMimeType || 'audio/webm' },
                    body: blob
                });
                if (!putRes.ok) throw new Error(`S3 upload failed: ${putRes.status}`);

                // 3. Process from S3
                const procRes = await fetch('/api/process-s3', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ key: upData.key, context: document.getElementById('placeholder') ? "" : document.getElementById('content').innerHTML })
                });
                if (!procRes.ok) throw new Error(`Backup failed: ${procRes.status}`);
                const data = await procRes.json();
                handleResult(data);
            } catch (e) {
                alert("Backup Upload Failed: " + e.message);
                updateStatus("Backup upload failed", "text-red-500");
                setRecordState('idle');
                modeLocked = false;
            }
        }

        function handlePrint() {
            consentAction = 'print';
            document.getElementById('consentModal').classList.remove('hidden');
        }

        function closeConsent() {
            document.getElementById('consentModal').classList.add('hidden');
        }

        function handleCopy() {
            consentAction = 'copy';
            document.getElementById('consentModal').classList.remove('hidden');
        }

        async function confirmConsent() {
            document.getElementById('consentModal').classList.add('hidden');
            if (consentAction === 'copy') {
                const success = await copyPrescription();
                if (success) updateStatus("Prescription copied", "text-green-600");
            } else {
                window.print();
            }
        }

        async function copyPrescription() {
            try {
                const content = document.getElementById('content');
                if (!content) return false;
                const text = content.innerText || "";
                if (!text.trim()) return false;
                await navigator.clipboard.writeText(text.trim());
                return true;
            } catch (_) {
                return false;
            }
        }

        function handleClear() {
            isRecording = false;
            modeLocked = false;
            if (timerInterval) clearInterval(timerInterval);
            elapsedSeconds = 0;
            transcriptBuffer = "";
            pendingHtml = "";
            backupAudioChunks = [];
            pcmQueue = [];
            setRecordState('idle');
            setTimerDisplayText("00:00");
            const badge = document.getElementById('countdownBadge');
            if (badge) badge.classList.add('hidden');
            const livePreview = document.getElementById('livePreview');
            if (livePreview) livePreview.innerText = "";
            const content = document.getElementById('content');
            if (content) content.innerHTML = '<p id="placeholder" class="text-slate-300 italic no-print">Tap to start prescription...</p>';
            updateStatus("READY", "text-gray-500");
        }

        function startTimer(reset = false) {
            const badge = document.getElementById('countdownBadge');
            if (reset) {
                elapsedSeconds = 0;
                setTimerDisplayText("00:00");
            }
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                elapsedSeconds++;
                const m = Math.floor(elapsedSeconds / 60);
                const s = elapsedSeconds % 60;
                setTimerDisplayText(`${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`);
                badge.classList.add('hidden');
            }, 1000);
        }

        // Events
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('modeMenu');
            const btn = document.getElementById('modeButton');
            if (!menu || !btn) return;
            if (!menu.classList.contains('hidden') && !menu.contains(e.target) && !btn.contains(e.target)) {
                closeModeMenu();
            }
            const fMenu = document.getElementById('fontMenu');
            const fBtn = document.getElementById('fontButton');
            if (fMenu && fBtn && !fMenu.classList.contains('hidden') && !fMenu.contains(e.target) && !fBtn.contains(e.target)) {
                closeFontMenu();
            }
        });

        // Macros Logic
        function openSettings() { document.getElementById('settingsModal').classList.remove('hidden'); }
        function openMacros() { 
            document.getElementById('macroModal').classList.remove('hidden'); 
            loadMacros();
        }
        async function loadMacros() {
            const res = await fetch('/api/macros');
            const data = await res.json();
            document.getElementById('macroList').innerHTML = data.map(m => `
                <div class="border-b py-2 flex justify-between items-start gap-2">
                    <div>
                        <div class="font-semibold text-gray-800">${m.trigger_phrase}</div>
                        <div class="text-gray-600 text-[11px] whitespace-pre-line">${m.expansion}</div>
                    </div>
                    <div class="flex flex-col gap-1">
                        <button class="text-blue-600 text-[11px] underline" onclick="editMacro('${m.trigger_phrase.replace(/'/g,"\\'")}','${m.expansion.replace(/'/g,"\\'")}')">Edit</button>
                        <button class="text-red-600 text-[11px] underline" onclick="deleteMacro('${m.trigger_phrase.replace(/'/g,"\\'")}')">Delete</button>
                    </div>
                </div>`).join('');
        }
        async function saveMacro() {
            await fetch('/api/macros', {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ trigger: document.getElementById('macroTrigger').value, expansion: document.getElementById('macroExpansion').value })
            });
            document.getElementById('macroTrigger').value = ''; document.getElementById('macroExpansion').value = '';
            loadMacros();
        }
        function editMacro(trigger, expansion) {
            document.getElementById('macroTrigger').value = trigger;
            document.getElementById('macroExpansion').value = expansion;
        }
        async function deleteMacro(trigger) {
            await fetch('/api/macros/delete', {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ trigger })
            });
            loadMacros();
        }

        const docHeaderEl = document.getElementById('docHeader');
        if (docHeaderEl) {
            setHeaderBaseline(docHeaderEl.innerHTML);
            docHeaderEl.addEventListener('input', markHeaderDirty);
        }

        applySelectedFontDefaults();
        syncFontControls();
        applyCurrentFontToHeader();
        setReviewEnabled(reviewEnabled);
        setRecordState('idle');
    </script>
</body>
</html>
