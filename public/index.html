<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SmartRx</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>@media print { .no-print { display: none !important; } body { background: white; } .print-area { border: none; box-shadow: none; padding: 0; } }</style>
</head>
<body class="bg-gray-100 min-h-screen p-4 font-sans">

    <!-- LOGIN UI -->
    <div id="loginScreen" class="min-h-screen flex items-center justify-center p-4">
        <div class="bg-white p-8 rounded-xl shadow-xl w-full max-w-md">
            <h1 class="text-2xl font-bold text-blue-900 mb-2">SmartRx Pro ðŸ©º</h1>
            <input id="loginPhone" placeholder="Phone Number" class="w-full border p-3 rounded mb-3">
            <input id="loginPass" type="password" placeholder="Password" class="w-full border p-3 rounded mb-4">
            <button onclick="login()" class="w-full bg-blue-600 text-white p-3 rounded font-bold hover:bg-blue-700">Login</button>
            <p onclick="toggleRegister()" class="text-center text-xs text-gray-400 mt-4 cursor-pointer hover:underline">Register</p>
        </div>
    </div>

    <!-- MAIN APP -->
    <div id="appScreen" class="hidden min-h-screen flex flex-col items-center p-4">
        <div class="w-full max-w-3xl flex justify-between items-center mb-4 no-print">
            <div class="text-blue-900 font-bold">SmartRx</div>
            <div class="flex gap-4 text-sm font-medium">
                <span class="bg-yellow-100 text-yellow-800 px-3 py-1 rounded-full">Credits: â‚¹<span id="creditDisplay">0</span></span>
                <button onclick="logout()" class="text-red-500">Logout</button>
            </div>
        </div>

        <div class="max-w-3xl w-full bg-white rounded-xl shadow-xl overflow-hidden print-area min-h-[85vh] flex flex-col relative">
            <div id="docHeader" contenteditable="true" class="p-8 border-b-2 border-gray-800 cursor-text hover:bg-gray-50 transition" onblur="saveHeader()"></div>
            <div id="livePreview" class="px-8 pt-2 text-gray-400 text-sm italic h-6 overflow-hidden"></div>
            <div id="content" contenteditable="true" class="p-8 flex-grow prose max-w-none focus:outline-none">
                <p id="placeholder" class="text-gray-300 italic no-print">Press Spacebar to dictate...</p>
            </div>
            <div class="bg-gray-50 p-4 border-t no-print">
            <div class="flex flex-col items-center gap-2">
                <div id="timerDisplay" class="text-gray-700 font-mono text-sm">00:00</div>
                <canvas id="waveform" class="w-full max-w-xs h-14 bg-black/5 rounded-lg"></canvas>
                <button id="recordFab" onclick="handleRecordAction()" class="w-20 h-20 rounded-full bg-red-600 text-white shadow-xl flex items-center justify-center transition-all active:scale-95">
                    <div id="recordIcon" class="w-6 h-6 rounded-full bg-white"></div>
                </button>
                <p id="recordLabel" class="text-xs font-semibold text-gray-700">Start Prescription</p>
            </div>
            <p id="status" class="text-center text-xs text-gray-500 font-bold mb-3 min-h-[1.5rem] whitespace-pre-line px-4">READY</p>
            <div class="flex justify-between items-center">
                <button onclick="document.getElementById('macroModal').classList.remove('hidden')" class="text-blue-600 text-sm font-semibold underline">ðŸ’Š Voice Macros</button>
                <div class="flex gap-2">
                    <button onclick="window.location.reload()" class="px-3 py-1 text-gray-500 text-xs">New Patient</button>
                    <button onclick="window.print()" class="bg-gray-900 text-white px-4 py-2 rounded text-sm font-bold">Print</button>
                </div>
            </div>
        </div>
        </div>
    </div>

    <!-- SETTINGS & MACRO MODALS (Standard) -->
    <div id="settingsModal" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-50 no-print">
        <div class="bg-white rounded p-6 w-full max-w-lg shadow-xl">
            <h2 class="font-bold mb-4">Settings</h2>
            <input id="in_name" placeholder="Name" class="w-full border p-2 mb-2 rounded">
            <input id="in_qual" placeholder="Qualifications" class="w-full border p-2 mb-2 rounded">
            <input id="in_reg" placeholder="Reg No" class="w-full border p-2 mb-2 rounded">
            <textarea id="in_clinic" placeholder="Clinic Address" class="w-full border p-2 mb-2 rounded"></textarea>
            <input id="in_keywords" placeholder="Keywords (Brand names)" class="w-full border p-2 mb-2 bg-yellow-50 rounded">
            <div class="flex justify-end gap-2">
                <button onclick="document.getElementById('settingsModal').classList.add('hidden')" class="px-4 py-2 text-gray-600">Cancel</button>
                <button onclick="saveSettings()" class="bg-blue-600 text-white px-4 py-2 rounded">Save</button>
            </div>
        </div>
    </div>

    <div id="macroModal" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-50 no-print">
        <div class="bg-white rounded p-6 w-full max-w-md shadow-xl">
            <h2 class="font-bold mb-4">Macros</h2>
            <input id="macroTrigger" placeholder="Trigger" class="w-full border p-2 mb-2 rounded">
            <textarea id="macroExpansion" placeholder="Expansion..." class="w-full border p-2 mb-2 rounded h-20"></textarea>
            <div class="flex justify-end gap-2">
                <button onclick="document.getElementById('macroModal').classList.add('hidden')" class="px-4 py-2 text-gray-600">Close</button>
                <button onclick="saveMacro()" class="bg-blue-600 text-white px-4 py-2 rounded">Save</button>
            </div>
            <div id="macroList" class="mt-4 pt-4 border-t text-xs h-32 overflow-y-auto"></div>
        </div>
    </div>

    <script>
        const getApiBase = () => {
            if (window.location.protocol === 'blob:' || window.location.origin === 'null') {
                return 'http://localhost:3000';
            }
            const host = window.location.hostname;
            if (host === 'localhost' || host === '127.0.0.1') {
                return window.location.port === '3000' ? '' : 'http://localhost:3000';
            }
            return '';
        };
        const API_BASE = getApiBase();
        const socket = API_BASE ? io(API_BASE) : io();
        
        let mediaRecorder, isRecording = false, transcriptBuffer = "", startTime = 0, timerInterval;
        let backupAudioChunks = [];
        let recordedMimeType = ''; // To store the browser's native mime type
        let audioCtx, sourceNode, processorNode, analyserNode, waveformAnim;
        let pcmQueue = [];
        let recordState = 'idle'; // idle | recording | processing

        // --- AUTH ---
        window.onload = initApp;
        async function login() {
            const phone = document.getElementById('loginPhone').value;
            const pass = document.getElementById('loginPass').value;
            const res = await fetch('/api/login', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ phone, password: pass }) });
            const data = await res.json();
            if (data.success) initApp(); else alert("Login Failed");
        }
        async function toggleRegister() {
            const phone = prompt("New Phone:"); const pass = prompt("New Password:");
            if(phone && pass) { await fetch('/api/register', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ phone, password: pass }) }); alert("Registered. Please login."); }
        }
        async function logout() { location.reload(); }
        async function initApp() {
            try {
                const res = await fetch('/api/me');
                if (res.status === 401) throw new Error("Unauthorized");
                const data = await res.json();
                document.getElementById('creditDisplay').innerText = data.credits;
                document.getElementById('docHeader').innerHTML = data.header_html || "<h1>Dr. Name</h1><p>Edit Header...</p>";
                document.getElementById('loginScreen').classList.add('hidden');
                document.getElementById('appScreen').classList.remove('hidden');
                loadMacros();
            } catch (e) {}
        }
        async function saveHeader() {
            await fetch('/api/header', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ html: document.getElementById('docHeader').innerHTML }) });
        }

        // --- SOCKET EVENTS ---
        socket.on('transcript-update', (data) => {
            const statusEl = document.getElementById('status');
            if (data.isFinal) {
                transcriptBuffer += " " + data.text;
                document.getElementById('livePreview').innerText = "";
                // Show last captured phrase in status
                updateStatus("CAPTURED:\n" + data.text, "text-blue-600");
            } else {
                document.getElementById('livePreview').innerText = data.text;
                // Show hearing phrase
                updateStatus("HEARING:\n" + data.text, "text-red-500");
            }
        });

        socket.on('prescription-result', (data) => {
            handleResult(data);
        });

        socket.on('use-backup-upload', () => {
            document.getElementById('status').innerText = "USING BACKUP...";
            document.getElementById('status').className = "text-center text-xs text-yellow-600 font-bold mb-4";
            uploadBackup();
        });

        function updateStatus(text, colorClass) {
            const statusEl = document.getElementById('status');
            statusEl.innerText = text;
            statusEl.className = `text-center text-xs font-bold mb-4 min-h-[1.5rem] whitespace-pre-line px-4 ${colorClass || 'text-gray-500'}`;
        }

        function setRecordState(state) {
            recordState = state;
            const fab = document.getElementById('recordFab');
            const icon = document.getElementById('recordIcon');
            const label = document.getElementById('recordLabel');

            if (state === 'idle') {
                fab.className = "w-20 h-20 rounded-full bg-red-600 text-white shadow-xl flex items-center justify-center transition-all active:scale-95";
                icon.className = "w-6 h-6 rounded-full bg-white";
                icon.style.borderRadius = "999px";
                label.innerText = "Start Prescription";
            } else if (state === 'recording') {
                fab.className = "w-20 h-20 rounded-full bg-red-700 text-white shadow-xl flex items-center justify-center transition-all scale-105";
                icon.className = "w-5 h-5 bg-white";
                icon.style.borderRadius = "6px";
                label.innerText = "Recording...";
            } else if (state === 'processing') {
                fab.className = "w-20 h-20 rounded-full bg-gray-700 text-white shadow-xl flex items-center justify-center transition-all animate-pulse";
                icon.className = "w-6 h-6 border-4 border-white border-t-transparent rounded-full animate-spin";
                icon.style.borderRadius = "999px";
                label.innerText = "Processing...";
            }
        }

        function startWaveform() {
            const canvas = document.getElementById('waveform');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            const dataArray = new Uint8Array(analyserNode.frequencyBinCount);

            const draw = () => {
                analyserNode.getByteTimeDomainData(dataArray);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "#e5e7eb";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = "#ef4444";
                ctx.lineWidth = 2;
                ctx.beginPath();
                const sliceWidth = canvas.width / dataArray.length;
                let x = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = (v * canvas.height) / 2;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                    x += sliceWidth;
                }
                ctx.stroke();
                waveformAnim = requestAnimationFrame(draw);
            };
            if (waveformAnim) cancelAnimationFrame(waveformAnim);
            waveformAnim = requestAnimationFrame(draw);
        }

        function stopWaveform() {
            if (waveformAnim) cancelAnimationFrame(waveformAnim);
            waveformAnim = null;
            const canvas = document.getElementById('waveform');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function flushPcmQueue() {
            if (!pcmQueue.length) return;
            const totalSamples = pcmQueue.reduce((sum, chunk) => sum + chunk.length, 0);
            const merged = new Int16Array(totalSamples);
            let offset = 0;
            pcmQueue.forEach(chunk => { merged.set(chunk, offset); offset += chunk.length; });
            pcmQueue = [];
            socket.emit('audio-stream', { type: 'pcm', data: merged.buffer });
        }

        function handleResult(data) {
            if (data.success) {
                document.getElementById('content').innerHTML = data.html;
                document.getElementById('creditDisplay').innerText = data.credits;
                updateStatus("DONE", "text-green-600");
            } else {
                alert(data.error);
                updateStatus("ERROR", "text-red-500");
            }
            setRecordState('idle');
        }

        // --- RECORDING (Native Streaming) ---
        async function startRecording() {
            if (isRecording || recordState === 'processing') return;
            transcriptBuffer = "";
            backupAudioChunks = [];
            startTime = Date.now();
            isPaused = false;
            updateStatus("LISTENING...", "text-red-500");
            document.getElementById('timerDisplay').innerText = "00:00";
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                // Live stream via AudioContext (16k PCM)
                audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                sourceNode = audioCtx.createMediaStreamSource(stream);
                analyserNode = audioCtx.createAnalyser();
                analyserNode.fftSize = 512;
                processorNode = audioCtx.createScriptProcessor(4096, 1, 1);
                sourceNode.connect(analyserNode);
                analyserNode.connect(processorNode);
                processorNode.connect(audioCtx.destination);

                processorNode.onaudioprocess = (e) => {
                    if (!isRecording) return;
                    const input = e.inputBuffer.getChannelData(0);
                    const pcm16 = new Int16Array(input.length);
                    for (let i = 0; i < input.length; i++) {
                        let s = Math.max(-1, Math.min(1, input[i]));
                        pcm16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                    }
                    pcmQueue.push(pcm16);
                    const totalSamples = pcmQueue.reduce((sum, chunk) => sum + chunk.length, 0);
                    if (totalSamples >= 12000) { // ~0.75s
                        const merged = new Int16Array(totalSamples);
                        let offset = 0;
                        pcmQueue.forEach(chunk => { merged.set(chunk, offset); offset += chunk.length; });
                        pcmQueue = [];
                        socket.emit('audio-stream', { type: 'pcm', data: merged.buffer });
                    }
                };

                // Backup recording for upload if live fails
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });
                recordedMimeType = mediaRecorder.mimeType; 
                mediaRecorder.ondataavailable = async (e) => {
                    if (e.data.size > 0) backupAudioChunks.push(e.data);
                };
                mediaRecorder.start(1500);

                isRecording = true;
                setRecordState('recording');
                startTimer();
                startWaveform();

            } catch (e) { alert("Mic Error: " + e.message); }
        }

        function handleRecordAction() {
            if (recordState === 'idle') startRecording();
            else if (recordState === 'recording') stopRecording();
        }

        function stopRecording() {
            if (!isRecording) return;
            isRecording = false;
            clearInterval(timerInterval);
            setRecordState('processing');
            flushPcmQueue();
            if (processorNode) { processorNode.disconnect(); processorNode.onaudioprocess = null; processorNode = null; }
            if (sourceNode) { sourceNode.disconnect(); sourceNode = null; }
            if (audioCtx) { audioCtx.close(); audioCtx = null; }
            pcmQueue = [];
            stopWaveform();

            if(mediaRecorder) mediaRecorder.stop();
            if(mediaRecorder && mediaRecorder.stream) mediaRecorder.stream.getTracks().forEach(t => t.stop());

            const duration = Date.now() - startTime;
            if (duration < 2000) { 
                updateStatus("Cancelled (<2s)", "text-gray-500");
                setRecordState('idle');
                return;
            }

            updateStatus("FORMATTING...", "text-blue-600");
            const cleanContext = document.getElementById('placeholder') ? "" : document.getElementById('content').innerHTML;
            
            const pendingPreview = document.getElementById('livePreview').innerText;
            const fullText = (transcriptBuffer + " " + pendingPreview).trim();

            setTimeout(() => {
                socket.emit('finalize-prescription', { fullTranscript: fullText, context: cleanContext });
            }, 2500);
        }

        // --- BACKUP UPLOAD ---
        async function uploadBackup() {
            const blob = new Blob(backupAudioChunks, { type: recordedMimeType });
            const formData = new FormData();
            formData.append('audio', blob, 'backup_audio');
            formData.append('context', document.getElementById('placeholder') ? "" : document.getElementById('content').innerHTML);

            try {
                const res = await fetch('/api/process-backup', { method: 'POST', body: formData });
                const data = await res.json();
                handleResult(data);
            } catch (e) {
                alert("Backup Upload Failed: " + e.message);
            }
        }

        function startTimer() {
            const timerEl = document.getElementById('timerDisplay');
            let secondsElapsed = 0;
            timerInterval = setInterval(() => {
                secondsElapsed++;
                const m = Math.floor(secondsElapsed / 60);
                const s = secondsElapsed % 60;
                timerEl.innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
            }, 1000);
        }

        // Events
        document.addEventListener('keydown', (e) => { if(e.code==='Space' && !e.repeat && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') handleRecordAction(); });
        document.addEventListener('keyup', (e) => { if(e.code==='Space' && recordState === 'recording') stopRecording(); });

        // Macros Logic
        function openSettings() { document.getElementById('settingsModal').classList.remove('hidden'); }
        function openMacros() { 
            document.getElementById('macroModal').classList.remove('hidden'); 
            loadMacros();
        }
        async function loadMacros() {
            const res = await fetch('/api/macros');
            const data = await res.json();
            document.getElementById('macroList').innerHTML = data.map(m => `<div class="border-b py-1"><b>${m.trigger_phrase}:</b> ${m.expansion}</div>`).join('');
        }
        async function saveMacro() {
            await fetch('/api/macros', {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ trigger: document.getElementById('macroTrigger').value, expansion: document.getElementById('macroExpansion').value })
            });
            document.getElementById('macroTrigger').value = ''; document.getElementById('macroExpansion').value = '';
            loadMacros();
        }

        setRecordState('idle');
    </script>
</body>
</html>
